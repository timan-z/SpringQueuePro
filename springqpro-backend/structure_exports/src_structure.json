{
  "project_info": {
    "name": "src",
    "path": "C:\\Users\\timan\\OneDrive\\Desktop\\Spring Boot Projects\\springqpro\\springqpro-backend\\src",
    "generated_at": "2025-12-12T15:03:51.2192212",
    "total_files": 84,
    "total_size": 290192
  },
  "structure": {
    "main": {
      "java": {
        "com": {
          "springqprobackend": {
            "springqpro": {
              "config": {
                "ExecutorConfig.java": {
                  "type": "file",
                  "info": {
                    "size": 2952,
                    "last_modified": "2025-12-12T15:03:49.9584433",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "GlobalExceptionHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 6275,
                    "last_modified": "2025-12-12T15:03:50.0113107",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "ProcessingMetricsConfig.java": {
                  "type": "file",
                  "info": {
                    "size": 3661,
                    "last_modified": "2025-12-12T15:03:50.0194032",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "QueueProperties.java": {
                  "type": "file",
                  "info": {
                    "size": 1631,
                    "last_modified": "2025-12-12T15:03:50.035179",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RedisConfig.java": {
                  "type": "file",
                  "info": {
                    "size": 4842,
                    "last_modified": "2025-12-12T15:03:50.0497219",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "SecurityConfig.java": {
                  "type": "file",
                  "info": {
                    "size": 5874,
                    "last_modified": "2025-12-12T15:03:50.0615313",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TaskHandlerProperties.java": {
                  "type": "file",
                  "info": {
                    "size": 3362,
                    "last_modified": "2025-12-12T15:03:50.0733092",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "controller": {
                "auth": {
                  "AuthenticationController.java": {
                    "type": "file",
                    "info": {
                      "size": 10129,
                      "last_modified": "2025-12-12T15:03:50.0932448",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  }
                },
                "controllerRecords.java": {
                  "type": "file",
                  "info": {
                    "size": 1511,
                    "last_modified": "2025-12-12T15:03:50.1115334",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "graphql": {
                  "GraphiQLRedirectController.java": {
                    "type": "file",
                    "info": {
                      "size": 370,
                      "last_modified": "2025-12-12T15:03:50.1248596",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "TaskGraphQLController.java": {
                    "type": "file",
                    "info": {
                      "size": 7571,
                      "last_modified": "2025-12-12T15:03:50.1366346",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  }
                },
                "rest": {
                  "ProcessingEventsController.java": {
                    "type": "file",
                    "info": {
                      "size": 1607,
                      "last_modified": "2025-12-12T15:03:50.1545523",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "ProducerController.java": {
                    "type": "file",
                    "info": {
                      "size": 8820,
                      "last_modified": "2025-12-12T15:03:50.1591268",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "SystemHealthController.java": {
                    "type": "file",
                    "info": {
                      "size": 2835,
                      "last_modified": "2025-12-12T15:03:50.1726354",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "TaskRestController.java": {
                    "type": "file",
                    "info": {
                      "size": 3173,
                      "last_modified": "2025-12-12T15:03:50.1864023",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  }
                }
              },
              "domain": {
                "entity": {
                  "TaskEntity.java": {
                    "type": "file",
                    "info": {
                      "size": 8179,
                      "last_modified": "2025-12-12T15:03:50.2121918",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "UserEntity.java": {
                    "type": "file",
                    "info": {
                      "size": 2292,
                      "last_modified": "2025-12-12T15:03:50.2247415",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  }
                },
                "event": {
                  "TaskCreatedEvent.java": {
                    "type": "file",
                    "info": {
                      "size": 310,
                      "last_modified": "2025-12-12T15:03:50.2418308",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  }
                },
                "exception": {
                  "TaskProcessingException.java": {
                    "type": "file",
                    "info": {
                      "size": 1239,
                      "last_modified": "2025-12-12T15:03:50.2636232",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  }
                }
              },
              "enums": {
                "TaskStatus.java": {
                  "type": "file",
                  "info": {
                    "size": 139,
                    "last_modified": "2025-12-12T15:03:50.2915762",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TaskType.java": {
                  "type": "file",
                  "info": {
                    "size": 199,
                    "last_modified": "2025-12-12T15:03:50.2950928",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "handlers": {
                "DataCleanUpHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 992,
                    "last_modified": "2025-12-12T15:03:50.3125043",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "DefaultHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 1089,
                    "last_modified": "2025-12-12T15:03:50.3268736",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "EmailHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 962,
                    "last_modified": "2025-12-12T15:03:50.3268736",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "FailAbsHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 1541,
                    "last_modified": "2025-12-12T15:03:50.3507796",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "FailHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 2471,
                    "last_modified": "2025-12-12T15:03:50.3605553",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "NewsLetterHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 987,
                    "last_modified": "2025-12-12T15:03:50.3705906",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "ReportHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 967,
                    "last_modified": "2025-12-12T15:03:50.3765259",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "SmsHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 952,
                    "last_modified": "2025-12-12T15:03:50.3922468",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TakesLongHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 982,
                    "last_modified": "2025-12-12T15:03:50.4022775",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TaskHandler.java": {
                  "type": "file",
                  "info": {
                    "size": 3065,
                    "last_modified": "2025-12-12T15:03:50.4124216",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "listeners": {
                "TaskCreatedListener.java": {
                  "type": "file",
                  "info": {
                    "size": 1218,
                    "last_modified": "2025-12-12T15:03:50.4237171",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "mapper": {
                "TaskMapper.java": {
                  "type": "file",
                  "info": {
                    "size": 2814,
                    "last_modified": "2025-12-12T15:03:50.463881",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "models": {
                "Task.java": {
                  "type": "file",
                  "info": {
                    "size": 6214,
                    "last_modified": "2025-12-12T15:03:50.4696339",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TaskHandlerRegistry.java": {
                  "type": "file",
                  "info": {
                    "size": 1902,
                    "last_modified": "2025-12-12T15:03:50.4855232",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "redis": {
                "RedisDistributedLock.java": {
                  "type": "file",
                  "info": {
                    "size": 3608,
                    "last_modified": "2025-12-12T15:03:50.5075434",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RedisTokenStore.java": {
                  "type": "file",
                  "info": {
                    "size": 2174,
                    "last_modified": "2025-12-12T15:03:50.5175508",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "Redis_Lua_Note.md": {
                  "type": "file",
                  "info": {
                    "size": 2287,
                    "last_modified": "2025-12-12T15:03:50.5215617",
                    "mime_type": "text/x-web-markdown",
                    "extension": ".md"
                  }
                },
                "TaskRedisRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 2643,
                    "last_modified": "2025-12-12T15:03:50.5335806",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "repository": {
                "TaskRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 5142,
                    "last_modified": "2025-12-12T15:03:50.5549391",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "UserRepository.java": {
                  "type": "file",
                  "info": {
                    "size": 670,
                    "last_modified": "2025-12-12T15:03:50.560958",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "runtime": {
                "Worker.java": {
                  "type": "file",
                  "info": {
                    "size": 3635,
                    "last_modified": "2025-12-12T15:03:50.5653393",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "security": {
                "CustomUserDetailsService.java": {
                  "type": "file",
                  "info": {
                    "size": 1840,
                    "last_modified": "2025-12-12T15:03:50.5969034",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "dto": {
                  "AuthRequest.java": {
                    "type": "file",
                    "info": {
                      "size": 123,
                      "last_modified": "2025-12-12T15:03:50.5969034",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "AuthResponse.java": {
                    "type": "file",
                    "info": {
                      "size": 131,
                      "last_modified": "2025-12-12T15:03:50.6127974",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "LoginRequest.java": {
                    "type": "file",
                    "info": {
                      "size": 121,
                      "last_modified": "2025-12-12T15:03:50.6198129",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "RefreshRequest.java": {
                    "type": "file",
                    "info": {
                      "size": 113,
                      "last_modified": "2025-12-12T15:03:50.6370836",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  },
                  "RegisterRequest.java": {
                    "type": "file",
                    "info": {
                      "size": 124,
                      "last_modified": "2025-12-12T15:03:50.6466087",
                      "mime_type": "text/x-java-source",
                      "extension": ".java"
                    }
                  }
                },
                "JwtAuthenticationFilter.java": {
                  "type": "file",
                  "info": {
                    "size": 4848,
                    "last_modified": "2025-12-12T15:03:50.664409",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "JwtUtil.java": {
                  "type": "file",
                  "info": {
                    "size": 5489,
                    "last_modified": "2025-12-12T15:03:50.6684199",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RefreshTokenService.java": {
                  "type": "file",
                  "info": {
                    "size": 1776,
                    "last_modified": "2025-12-12T15:03:50.6821275",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "service": {
                "ProcessingService.java": {
                  "type": "file",
                  "info": {
                    "size": 21909,
                    "last_modified": "2025-12-12T15:03:50.7013349",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "QueueService.java": {
                  "type": "file",
                  "info": {
                    "size": 14736,
                    "last_modified": "2025-12-12T15:03:50.7091055",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TaskService.java": {
                  "type": "file",
                  "info": {
                    "size": 8865,
                    "last_modified": "2025-12-12T15:03:50.7191401",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "SpringQueueProApplication.java": {
                "type": "file",
                "info": {
                  "size": 341,
                  "last_modified": "2025-12-12T15:03:50.7228938",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "util": {
                "RealSleeper.java": {
                  "type": "file",
                  "info": {
                    "size": 854,
                    "last_modified": "2025-12-12T15:03:50.7447939",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "Sleeper.java": {
                  "type": "file",
                  "info": {
                    "size": 161,
                    "last_modified": "2025-12-12T15:03:50.7545618",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              }
            }
          }
        }
      },
      "resources": {
        "application-prod.yml": {
          "type": "file",
          "info": {
            "size": 1200,
            "last_modified": "2025-12-12T15:03:50.7981769",
            "mime_type": "text/x-yaml",
            "extension": ".yml"
          }
        },
        "application.properties": {
          "type": "file",
          "info": {
            "size": 445,
            "last_modified": "2025-12-12T15:03:50.8022552",
            "mime_type": "text/x-java-properties",
            "extension": ".properties"
          }
        },
        "application.yml": {
          "type": "file",
          "info": {
            "size": 1092,
            "last_modified": "2025-12-12T15:03:50.8182103",
            "mime_type": "text/x-yaml",
            "extension": ".yml"
          }
        },
        "graphql": {
          "schema.graphqls": {
            "type": "file",
            "info": {
              "size": 2711,
              "last_modified": "2025-12-12T15:03:50.8182103",
              "mime_type": "text/plain",
              "extension": ".graphqls"
            }
          }
        },
        "static": {
          "graphiql": {
            "index.html": {
              "type": "file",
              "info": {
                "size": 5048,
                "last_modified": "2025-12-12T15:03:50.8338869",
                "mime_type": "text/html",
                "extension": ".html"
              }
            }
          }
        },
        "templates": {
        }
      }
    },
    "test": {
      "java": {
        "com": {
          "springqprobackend": {
            "springqpro": {
              "config": {
                "RedisTestConfig.java": {
                  "type": "file",
                  "info": {
                    "size": 3087,
                    "last_modified": "2025-12-12T15:03:50.9151985",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "handlers": {
                "DefaultHandlerTests.java": {
                  "type": "file",
                  "info": {
                    "size": 2619,
                    "last_modified": "2025-12-12T15:03:50.9290038",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "FailHandlerTests.java": {
                  "type": "file",
                  "info": {
                    "size": 6204,
                    "last_modified": "2025-12-12T15:03:50.9434849",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "integration": {
                "AuthJwtIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 12357,
                    "last_modified": "2025-12-12T15:03:50.9590312",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "CreateAndProcessTaskIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 5141,
                    "last_modified": "2025-12-12T15:03:50.966794",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "OwnershipGraphQLIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 9713,
                    "last_modified": "2025-12-12T15:03:50.976885",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "ProcessingConcurrencyIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 4239,
                    "last_modified": "2025-12-12T15:03:50.976885",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RedisDistributedLockIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 4010,
                    "last_modified": "2025-12-12T15:03:50.9948293",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RedisPingIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 1741,
                    "last_modified": "2025-12-12T15:03:50.9948293",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RetryBehaviorIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 6422,
                    "last_modified": "2025-12-12T15:03:51.0105589",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TaskCacheIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 3708,
                    "last_modified": "2025-12-12T15:03:51.0215997",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "TaskGraphQLIntegrationTest.java": {
                  "type": "file",
                  "info": {
                    "size": 12908,
                    "last_modified": "2025-12-12T15:03:51.0306777",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "models": {
                "TaskHandlerRegistryTests.java": {
                  "type": "file",
                  "info": {
                    "size": 2295,
                    "last_modified": "2025-12-12T15:03:51.0404365",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "runtime": {
                "WorkerTests.java": {
                  "type": "file",
                  "info": {
                    "size": 2089,
                    "last_modified": "2025-12-12T15:03:51.0646538",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "service": {
                "QueueServiceTests.java": {
                  "type": "file",
                  "info": {
                    "size": 13612,
                    "last_modified": "2025-12-12T15:03:51.0724229",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              },
              "SpringQueueProApplicationTests.java": {
                "type": "file",
                "info": {
                  "size": 389,
                  "last_modified": "2025-12-12T15:03:51.0957773",
                  "mime_type": "text/x-java-source",
                  "extension": ".java"
                }
              },
              "testcontainers": {
                "BasePostgresContainer.java": {
                  "type": "file",
                  "info": {
                    "size": 1878,
                    "last_modified": "2025-12-12T15:03:51.1062678",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "BaseRedisContainer.java": {
                  "type": "file",
                  "info": {
                    "size": 498,
                    "last_modified": "2025-12-12T15:03:51.1136166",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "IntegrationTestBase.java": {
                  "type": "file",
                  "info": {
                    "size": 646,
                    "last_modified": "2025-12-12T15:03:51.126198",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                },
                "RedisIntegrationTestBase.java": {
                  "type": "file",
                  "info": {
                    "size": 1287,
                    "last_modified": "2025-12-12T15:03:51.1359884",
                    "mime_type": "text/x-java-source",
                    "extension": ".java"
                  }
                }
              }
            }
          }
        }
      },
      "resources": {
        "application-test.properties": {
          "type": "file",
          "info": {
            "size": 74,
            "last_modified": "2025-12-12T15:03:51.183369",
            "mime_type": "text/x-java-properties",
            "extension": ".properties"
          }
        },
        "application-test.yml": {
          "type": "file",
          "info": {
            "size": 62,
            "last_modified": "2025-12-12T15:03:51.1933987",
            "mime_type": "text/x-yaml",
            "extension": ".yml"
          }
        }
      }
    }
  },
  "files": [
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\config\\ExecutorConfig.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\n\r\n/* ExecutorConfig.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nEarly prototypes created thread pools directly inside QueueService. As more\r\nparallelism was added (ProcessingService, retry scheduling, GraphQL execution),\r\nthe need for controlled, centralized executor configuration became clear.\r\nExecutorConfig externalized thread pool creation and tuning.\r\n\r\n[CURRENT ROLE]:\r\nProvides:\r\n  - primary ExecutorService (fixed thread pool)\r\n  - ScheduledExecutorService for retry/backoff scheduling\r\nUsed by:\r\n  - QueueService (submit tasks)\r\n  - ProcessingService (delayed retries)\r\n\r\n[FUTURE WORK]:\r\nCloudQueue may adopt:\r\n  - managed executors\r\n  - Quartz scheduling\r\n  - asynchronous dispatcher microservices\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n// 2025-11-30-NOTE: Ignore the two comment blocks below.\r\n/* NOTE-TO-SELF: Now that I'm wiring in ExecutorService and ScheduledExecutorService, there are definitely\r\nadjustments that I need to make to my existing Unit Tests that I'll need to make before writing Integration Tests! (DEBUG: REMEMBER).\r\n*/\r\n/* 2025-11-14-DEBUG:+NOTE(S)-TO-SELF:\r\nOriginally, in QueueService, during the prototype phase of this project, I had ScheduledExecutor declared manually.\r\nThat's fine for prototypes, but in Spring Boot apps with persistence and long-lived threads (my project target), manual\r\nexecutors create hidden lifecycle and monitoring issues. With the Executors being injected,\r\n- Life Cycle is now managed: Spring will gracefully shut down the executor on app close - no lingering threads. (So maybe I do just remove the @PreDestory thing?)\r\n- Thread-Pool Reuse: One Scheduled Executor is now shared across components (e.g., QueueService and ProcessingService).\r\nThis is better and more professional so yeah.\r\n*/\r\n@Configuration\r\npublic class ExecutorConfig {\r\n    // Field(s):\r\n    private QueueProperties props;  // NOTE: QueueProperties is in the same package so no import needed (DEBUG: May change down the line?).\r\n\r\n    public ExecutorConfig(QueueProperties props) { this.props = props; }\r\n\r\n    @Bean(\"execService\")\r\n    public ExecutorService taskExecutor() {\r\n       return Executors.newFixedThreadPool(props.getMainExecWorkerCount(), r -> {\r\n           Thread t = new Thread(r);\r\n           t.setName(\"QS-Worker-\" + t.getId());\r\n           return t;\r\n       });\r\n    }\r\n\r\n    @Bean(\"schedExec\")\r\n    public ScheduledExecutorService taskScheduler() {\r\n        return Executors.newScheduledThreadPool(props.getSchedExecWorkerCount());\r\n    }\r\n}\r\n",
      "info": {
        "size": 2952,
        "last_modified": "2025-12-12T15:03:49.9584433",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\config\\GlobalExceptionHandler.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport com.fasterxml.jackson.databind.exc.InvalidFormatException;\r\nimport io.jsonwebtoken.ExpiredJwtException;\r\nimport io.jsonwebtoken.JwtException;\r\nimport org.apache.catalina.connector.Response;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.authentication.BadCredentialsException;\r\nimport org.springframework.validation.FieldError;\r\nimport org.springframework.web.bind.MethodArgumentNotValidException;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.server.ResponseStatusException;\r\n\r\nimport java.time.Instant;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/* GlobalExceptionHandler.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nAs the project grew (JWT, GraphQL, REST, Redis, PostgreSQL), exceptions became\r\nmore varied and harder to track. This global handler was introduced to unify\r\nerror output and provide consistent JSON responses.\r\n\r\n[CURRENT ROLE]:\r\nHandles:\r\n  - validation failures\r\n  - missing tokens\r\n  - invalid credentials\r\n  - parsing errors\r\n  - unexpected exceptions\r\nEnsures clients receive predictable HTTP responses instead of raw stack traces.\r\n\r\n[FUTURE WORK]:\r\nCloudQueue may expand this into:\r\n  - structured error codes\r\n  - correlation IDs for distributed tracing\r\n  - Sentry / CloudWatch integration\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n// 2025-11-30-NOTE: Preserve the two comment blocks below for future documentation.\r\n/* 2025-11-25-NOTE(S):\r\n- EXPANDING THIS TO HANDLE INVALID CREDENTIALS AND JWT-RELATED ERRORS ENCOUNTERED IN AuthenticationController.java\r\n- OVERHAULING EXISTING METHODS TO MAKE RESPONSES MORE BROAD AND GENERAL AND NOT SO SPECIFIC LIKE THEY ORIGINALLY WERE TO THE EARLIER PHASES OF THIS PROJECT.\r\n*/\r\n/* IMPORTANT FUTURE REFINEMENT TO-DO:\r\nJWT errors thrown inside JwtAuthenticationFilter are just caught in the filter and logged, they won't hit this handler.\r\nMy security rules just treat the request as anonymous and Spring Security itself returns a basic 401.\r\nLater, maybe add a custom AuthenticationEntryPoint so we can have full JSON control over the 401 from the filter...\r\nCURRENTLY RUSHING TO GET A MVP OUT AND READY FOR DEPLOYMENT AND DSIPLAY!!!\r\n*/\r\n@RestControllerAdvice   // NOTE: applies across all controllers (like a global try-catch).\r\npublic class GlobalExceptionHandler {\r\n    // RETURN BODY TEMPLATE:\r\n    private Map<String, Object> baseBody(String message) {\r\n        Map<String, Object> body = new HashMap<>();\r\n        body.put(\"timestamp\", Instant.now().toString());\r\n        body.put(\"error\", message);\r\n        return body;\r\n    }\r\n    // 2025-11-25-NOTE: MY OLD HANDLERS (FROM PRE-JWT REFACTORING, NOW REFACTORED AS PART OF THE JWT OVERHAUL):\r\n    // INVALID ENUM HANDLER: (e.g., invalid TaskType in JSON payload).\r\n    @ExceptionHandler(InvalidFormatException.class)\r\n    public ResponseEntity<Map<String, Object>> handleInvalidEnum(InvalidFormatException ex) {\r\n        Map<String, Object> body = baseBody(\"Invalid value in the request body\");\r\n        body.put(\"details\", ex.getValue() != null ? ex.getValue().toString() : null);\r\n        // Special-case: enums (e.g., invalid TaskType / TaskStatus)\r\n        if (ex.getTargetType() != null && ex.getTargetType().isEnum()) {\r\n            body.put(\"hint\", \"Check your enum value (TaskType / TaskStatus, etc.)\");    // NOTE: Old message was specifically about invalid Type/Status etc.\r\n        }\r\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(body);\r\n    }\r\n\r\n    // VALIDATION ERROR HANDLER (from Bean Annotation in Task.java): (e.g., violations of @NotNull, @NotBlank, and so on).\r\n    @ExceptionHandler(MethodArgumentNotValidException.class)    // triggered automatically for any @Valid @RequestBody validation failure.\r\n    public ResponseEntity<Map<String, Object>> handleValidationErrors(MethodArgumentNotValidException ex) {\r\n        Map<String, Object> body = baseBody(\"Validation failed\");\r\n        Map<String, String> fieldErrors = new HashMap<>();\r\n        for (FieldError fe : ex.getBindingResult().getFieldErrors()) {\r\n            fieldErrors.put(fe.getField(), fe.getDefaultMessage());\r\n        }\r\n        body.put(\"fields\", fieldErrors);\r\n        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(body);\r\n    }\r\n\r\n    // FALLBACK HANDLER: For unexpected exceptions:\r\n    @ExceptionHandler(Exception.class)\r\n    public ResponseEntity<Map<String, Object>> handleGenericErrors(Exception ex) {\r\n        Map<String, Object> body = baseBody(\"Unexpected server error\");\r\n        body.put(\"details\", ex.getClass().getSimpleName());\r\n        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(body);\r\n    }\r\n\r\n    // 2025-11-25-NOTE:+DEBUG: JWT-RELATED ERRORS HANDLED BELOW:\r\n    @ExceptionHandler(BadCredentialsException.class)\r\n    public ResponseEntity<Map<String, Object>> handleBadCredentials(BadCredentialsException ex) {\r\n        Map<String, Object> body = baseBody(\"Invalid credentials\");\r\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(body);\r\n    }\r\n    @ExceptionHandler(ExpiredJwtException.class)\r\n    public ResponseEntity<Map<String, Object>> handleExpiredJwt(ExpiredJwtException ex) {\r\n        Map<String, Object> body = baseBody(\"JWT token expired\");\r\n        body.put(\"details\", ex.getMessage());\r\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(body);\r\n    }\r\n    @ExceptionHandler(JwtException.class)\r\n    public ResponseEntity<Map<String, Object>> handleJwt(JwtException ex) {\r\n        Map<String, Object> body = baseBody(\"Invalid JWT token\");\r\n        body.put(\"details\", ex.getMessage());\r\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(body);\r\n    }\r\n    @ExceptionHandler(ResponseStatusException.class)\r\n    public ResponseEntity<Map<String, Object>> handleResponseStatus(ResponseStatusException ex) {\r\n        Map<String, Object> body = baseBody(ex.getReason() != null ? ex.getReason() : \"Request failed\");\r\n        return ResponseEntity.status(ex.getStatusCode()).body(body);\r\n    }\r\n}\r\n",
      "info": {
        "size": 6275,
        "last_modified": "2025-12-12T15:03:50.0113107",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\config\\ProcessingMetricsConfig.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport com.springqprobackend.springqpro.service.QueueService;\r\nimport io.micrometer.core.instrument.Gauge;\r\nimport io.micrometer.core.instrument.MeterRegistry;\r\nimport io.micrometer.core.instrument.Counter;\r\nimport io.micrometer.core.instrument.Timer;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\npublic class ProcessingMetricsConfig {\r\n    @Bean\r\n    public Counter tasksSubmittedCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_tasks_submitted_total\")\r\n                .description(\"Total tasks submitted/created.\")\r\n                .register(registry);\r\n    }\r\n    @Bean\r\n    public Counter tasksClaimedCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_tasks_claimed_total\")\r\n                .description(\"Total DB-backed tasks successfully claimed for processing.\")\r\n                .register(registry);\r\n    }\r\n    @Bean\r\n    public Counter tasksCompletedCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_tasks_completed_total\")\r\n                .description(\"Total successfully completed tasks.\")\r\n                .register(registry);\r\n    }\r\n    @Bean\r\n    public Counter tasksFailedCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_tasks_failed_total\")\r\n                .description(\"Total failed tasks\")\r\n                .register(registry);\r\n    }\r\n    @Bean\r\n    public Counter tasksRetriedCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_tasks_retried_total\")\r\n                .description(\"Total scheduled retries\")\r\n                .register(registry);\r\n    }\r\n    @Bean\r\n    public Timer processingTimer(MeterRegistry registry) {\r\n        return Timer.builder(\"springqpro_task_processing_duration\")\r\n                .description(\"Time spent executing task handlers\")\r\n                .publishPercentiles(0.50, 0.90, 0.95, 0.99)\r\n                .publishPercentileHistogram()\r\n                .register(registry);\r\n    }\r\n    // The one below is for the number of tasks made by users sending GraphQL queries:\r\n    @Bean\r\n    public Counter apiTaskCreateCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_api_task_create_total\")\r\n                .description(\"Tasks created from GraphQL API\")\r\n                .register(registry);\r\n    }   // TO-DO: GraphQL is my main API thing, but I'm keeping the REST stuff too -- maybe add another Counter for that specifically?\r\n    @Bean\r\n    public Counter queueEnqueueCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_queue_enqueue_total\")\r\n                .description(\"In-memory enqueue() calls (legacy path)\")\r\n                .register(registry);\r\n    }   // <-- DEBUG: I can't remember if this is even used anymore at this point in the program...\r\n    @Bean\r\n    public Counter queueEnqueueByIdCounter(MeterRegistry registry) {\r\n        return Counter.builder(\"springqpro_queue_enqueue_by_id_total\")\r\n                .description(\"enqueueById() calls feeding into ProcessingService\")\r\n                .register(registry);\r\n    }\r\n    @Bean\r\n    public Gauge inMemoryQueueSizeGauge(MeterRegistry registry, QueueService queueService) {\r\n        return Gauge.builder(\"springqpro_queue_memory_size\", queueService, q -> q.getJobMapCount())\r\n                .description(\"Number of tasks currently in legacy in-memory queue\")\r\n                .register(registry);\r\n    }   // <-- DEBUG: I can't remember if this is even used anymore at this point in the program...\r\n}\r\n",
      "info": {
        "size": 3661,
        "last_modified": "2025-12-12T15:03:50.0194032",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\config\\QueueProperties.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;\r\nimport org.springframework.stereotype.Component;\r\n\r\n/* QueueProperties.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nWhen retry logic, parallelism, and sleep durations were hardcoded, tuning the\r\nqueue meant editing Java source. QueueProperties was introduced so these values\r\ncould be configured externally.\r\n\r\n[CURRENT ROLE]:\r\nMaps application.yml values for:\r\n  - executor thread counts\r\n  - scheduled executor workers\r\n  - default delays\r\n  - retry policies\r\nThese values directly affect ProcessingService + QueueService behavior.\r\n\r\n[FUTURE WORK]:\r\nCloudQueue might:\r\n  - dynamically tune these values based on load\r\n  - store them in AWS Parameter Store or Secrets Manager\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@ConfigurationProperties(prefix=\"queue\")\r\n@Component\r\npublic class QueueProperties {\r\n    private int mainExecWorkerCount;\r\n    private int schedExecWorkerCount;\r\n\r\n    // getters:\r\n    public int getMainExecWorkerCount() {\r\n        return mainExecWorkerCount;\r\n    }\r\n    public int getSchedExecWorkerCount() {\r\n        return schedExecWorkerCount;\r\n    }\r\n    // setters:\r\n    public void setMainExecWorkerCount(int mainExecWorkerCount) {\r\n        this.mainExecWorkerCount = mainExecWorkerCount;\r\n    }\r\n    public void setSchedExecWorkerCount(int schedExecWorkerCount) {\r\n        this.schedExecWorkerCount = schedExecWorkerCount;\r\n    }\r\n}\r\n",
      "info": {
        "size": 1631,
        "last_modified": "2025-12-12T15:03:50.035179",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\config\\RedisConfig.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\r\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\r\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Profile;\r\nimport org.springframework.data.redis.connection.RedisPassword;\r\nimport org.springframework.data.redis.connection.RedisStandaloneConfiguration;\r\nimport org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration;\r\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\n\r\n/* RedisConfig.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nRedis integration began when the system needed:\r\n  - refresh token storage for JWT\r\n  - distributed locking for multi-instance safety\r\n  - high-performance caching for task reads\r\nRedisConfig is where the Redis connection factory and templates are created.\r\n\r\n[CURRENT ROLE]:\r\nDefines:\r\n  - LettuceConnectionFactory\r\n  - RedisTemplate<String, Object>\r\n  - StringRedisTemplate\r\nThese beans are used for:\r\n  - RedisTokenStore\r\n  - RedisDistributedLock\r\n  - TaskRedisRepository\r\n[FUTURE WORK]:\r\nCloudQueue may:\r\n  - adopt RedissonClient\r\n  - use Redis Cluster mode\r\n  - enable connection pooling and pipelining\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n// 2025-11-21-REDIS-PHASE-NOTE: THIS FILE CREATES CONNECTION FACTORY AND REDIS TEMPLATE W/ JACKSON SERIALIZER:\r\n@Profile(\"!test\")\r\n@Configuration\r\npublic class RedisConfig {\r\n    @Bean\r\n    public LettuceConnectionFactory redisConnectionFactory(\r\n            @Value(\"${spring.redis.host}\") String host,\r\n            @Value(\"${spring.redis.port}\") int port,\r\n            @Value(\"${spring.redis.password}\") String password,\r\n            @Value(\"${spring.redis.ssl}\") boolean ssl   // default to false is missing\r\n    ) {\r\n        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();\r\n        config.setHostName(host);\r\n        config.setPort(port);\r\n        if (password != null && !password.isBlank()) {\r\n            config.setPassword(RedisPassword.of(password));\r\n        }\r\n        LettuceClientConfiguration.LettuceClientConfigurationBuilder builder = LettuceClientConfiguration.builder();\r\n        if (ssl) {\r\n            builder.useSsl();\r\n        }\r\n        LettuceClientConfiguration clientConfig = builder.build();\r\n        return new LettuceConnectionFactory(config, clientConfig);\r\n        /*LettuceClientConfiguration clientConfig =\r\n                LettuceClientConfiguration.builder()\r\n                        .useSsl()     // NOTE: REQUIRED for Railway Redis\r\n                        .build();\r\n        return new LettuceConnectionFactory(config, clientConfig);*/\r\n    }\r\n\r\n    @Bean\r\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory connectionFactory) {\r\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\r\n        template.setConnectionFactory(connectionFactory);\r\n        // Use Jackson JSON serializer for values -- keeps Task metadata readable and avoids Java native serialization pitfalls.\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\r\n        mapper.registerModule(new JavaTimeModule());\r\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\r\n        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);\r\n\r\n        GenericJackson2JsonRedisSerializer jackson = new GenericJackson2JsonRedisSerializer(mapper);\r\n\r\n        template.setKeySerializer(new StringRedisSerializer());\r\n        template.setValueSerializer(jackson);\r\n        template.setHashKeySerializer(new StringRedisSerializer());\r\n        template.setHashValueSerializer(jackson);\r\n        template.afterPropertiesSet();\r\n        return template;\r\n    }\r\n\r\n    @Bean\r\n    public StringRedisTemplate stringRedisTemplate(LettuceConnectionFactory factory) {\r\n        return new StringRedisTemplate(factory);\r\n    }\r\n}\r\n",
      "info": {
        "size": 4842,
        "last_modified": "2025-12-12T15:03:50.0497219",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\config\\SecurityConfig.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport com.springqprobackend.springqpro.security.JwtAuthenticationFilter;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.http.HttpMethod;\r\nimport org.springframework.security.config.Customizer;\r\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.http.SessionCreationPolicy;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.security.web.SecurityFilterChain;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\nimport org.springframework.web.cors.CorsConfiguration;\r\nimport org.springframework.web.cors.CorsConfigurationSource;\r\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\r\n\r\nimport java.util.List;\r\n\r\n/* SecurityConfig.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nOriginally, the project had no security at all. Endpoints were completely open.\r\nOnce the system became stateful (PostgreSQL, Redis), authentication and proper\r\nauthorization became mandatory.\r\nSecurityConfig now serves as the top-level Spring Security configuration.\r\n\r\n[CURRENT ROLE]:\r\nConfigures:\r\n  - stateless JWT authentication\r\n  - JwtAuthenticationFilter chain\r\n  - route protection for REST + GraphQL\r\n  - CSRF disabling (since the system is token-based)\r\n  - session policy (STATELESS)\r\n\r\nAlso integrates seamlessly with:\r\n  - AuthenticationController\r\n  - CustomUserDetailsService\r\n  - GraphQL security checks\r\n\r\n[FUTURE WORK]:\r\nCloudQueue may adopt:\r\n  - CORS tightening\r\n  - role-based access control\r\n  - AWS Cognito JWT verification\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n// 2025-12-05-NOTE:+DEBUG: Additions today are related to configuring CORS on the backend so my frontend can send API requests.\r\n\r\n@EnableWebSecurity\r\n@EnableMethodSecurity\r\n@Configuration\r\npublic class SecurityConfig {\r\n    private final JwtAuthenticationFilter jwtFilter;\r\n    public SecurityConfig(JwtAuthenticationFilter jwtFilter) {\r\n        this.jwtFilter = jwtFilter;\r\n    }\r\n    /* Supported routes:\r\n    PUBLIC: /auth/**, /actuator/health\r\n    PRIVATE: /api/tasks/**, /graphql\r\n    */\r\n    @Bean\r\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\r\n        /* IMPORTANT-NOTE (line of code below this comment block) - Enabling CORS so that:\r\n        - GraphiQL (my Browser client) can call POST /graphql\r\n        - Future REACT frontend / Cloud deployment / API Gateway can access the API (obv important for deployment).\r\n        - Modern Spring Security requires explicit CORS in stateless JWT apps.\r\n        withDefaults() basically means:\r\n        - Use Spring Boot's auto CORS config (from application.yml)\r\n        - Do not block browser to backend API calls.\r\n        */\r\n        http.cors(Customizer.withDefaults());\r\n        http.csrf(csrf -> csrf.disable())\r\n                .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\r\n                .authorizeHttpRequests(auth -> auth\r\n                        .requestMatchers(\"/auth/**\").permitAll()\r\n                        .requestMatchers(\"/actuator/health\").permitAll()\r\n                        .requestMatchers(\"/auth/register\").permitAll()\r\n                        .requestMatchers(\"/auth/login\").permitAll()\r\n                        .requestMatchers(\"/auth/refresh\").permitAll()\r\n                        // GraphQL endpoint - EDIT: Adjusted so secured only for POST since GraphQL ops only use POST. (GET shouldn't req authentication).\r\n                        .requestMatchers(HttpMethod.POST,\"/graphql\").authenticated()\r\n                        // REST endpoints (I know that GraphQL is my main thing now -- but I might as well have these, also it's TaskRestController that will replace these).\r\n                        .requestMatchers(\"/api/tasks/**\").authenticated()\r\n                        .anyRequest().permitAll()\r\n                )\r\n                // Attach JWT Filter (run BEFORE UsernamePasswordAuthenticationFilter):\r\n                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\r\n        return http.build();\r\n    }\r\n    @Bean\r\n    public PasswordEncoder encoder() {\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n    // 2025-12-05-NOTE: ADDED BELOW FOR CORS STUFF.\r\n    @Bean\r\n    public CorsConfigurationSource corsConfigurationSource() {\r\n        CorsConfiguration config = new CorsConfiguration();\r\n        // Allowed origins for frontend\r\n        config.setAllowedOrigins(List.of(\r\n                \"http://localhost:5173\",                // local dev (TO-DO: append Netlify link later when frontend is deployed).\r\n                \"https://springqueuepro.netlify.app\"\r\n        ));\r\n        // Important for JWT/Auth\r\n        config.setAllowCredentials(true);\r\n        config.setAllowedMethods(List.of(\r\n                \"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"\r\n        ));\r\n        config.setAllowedHeaders(List.of(\r\n                \"Authorization\",\r\n                \"Content-Type\"\r\n        ));\r\n        // Optional: Expose Authorization header if needed\r\n        config.setExposedHeaders(List.of(\"Authorization\"));\r\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\r\n        source.registerCorsConfiguration(\"/**\", config);\r\n        return source;\r\n    }\r\n}\r\n",
      "info": {
        "size": 5874,
        "last_modified": "2025-12-12T15:03:50.0615313",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\config\\TaskHandlerProperties.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport org.springframework.boot.context.properties.ConfigurationProperties;\r\nimport org.springframework.stereotype.Component;\r\n\r\n/* TaskHandlerProperties.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nEarly handlers hardcoded sleep times directly inside the Java classes. As more\r\ntask types were added (EMAIL, FAIL, TAKESLONG, etc.), these constants had to be\r\nexternalized, configurable, and manageable.\r\n\r\nThis @ConfigurationProperties class was introduced to load handler timing values\r\nfrom application.yml.\r\n\r\n[CURRENT ROLE]:\r\nProvides per-handler configurable values such as:\r\n  - simulated processing time\r\n  - fail-retry timing\r\n  - long-running task timing\r\n\r\nThese properties improve realism and make load testing more consistent.\r\n\r\n[FUTURE WORK]:\r\nCloudQueue may:\r\n  - load these values dynamically from Redis\r\n  - expose them in an admin panel\r\n  - adjust them adaptively under load\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@ConfigurationProperties(prefix=\"t-handler\")\r\n@Component\r\npublic class TaskHandlerProperties {\r\n    private long defaultSleepTime;\r\n    private long dataCleanUpSleepTime;\r\n    private long emailSleepTime;\r\n    private long failSleepTime;\r\n    private long failSuccSleepTime;\r\n    private long failAbsSleepTime;\r\n    private long newsLetterSleepTime;\r\n    private long reportSleepTime;\r\n    private long smsSleepTime;\r\n    private long takesLongSleepTime;\r\n\r\n    // getters:\r\n    public long getDefaultSleepTime() { return defaultSleepTime; }\r\n    public long getDataCleanUpSleepTime() { return dataCleanUpSleepTime; }\r\n    public long getEmailSleepTime() { return emailSleepTime; }\r\n    public long getFailSleepTime() { return failSleepTime; }\r\n    public long getFailSuccSleepTime() { return failSuccSleepTime; }\r\n    public long getFailAbsSleepTime() { return failAbsSleepTime; }\r\n    public long getNewsLetterSleepTime() { return newsLetterSleepTime; }\r\n    public long getReportSleepTime() { return reportSleepTime; }\r\n    public long getSmsSleepTime() { return smsSleepTime; }\r\n    public long getTakesLongSleepTime() { return takesLongSleepTime; }\r\n    // setters:\r\n    public void setDefaultSleepTime(long defaultSleepTime) { this.defaultSleepTime = defaultSleepTime; }\r\n    public void setDataCleanUpSleepTime(long dataCleanUpSleepTime) { this.dataCleanUpSleepTime = dataCleanUpSleepTime; }\r\n    public void setEmailSleepTime(long emailSleepTime) { this.emailSleepTime = emailSleepTime; }\r\n    public void setFailSleepTime(long failSleepTime) { this.failSleepTime = failSleepTime; }\r\n    public void setFailSuccSleepTime(long failSuccSleepTime) { this.failSuccSleepTime = failSuccSleepTime; }\r\n    public void setFailAbsSleepTime(long failAbsSleepTime) { this.failAbsSleepTime = failAbsSleepTime; }\r\n    public void setNewsLetterSleepTime(long newsLetterSleepTime) { this.newsLetterSleepTime = newsLetterSleepTime; }\r\n    public void setReportSleepTime(long reportSleepTime) { this.reportSleepTime = reportSleepTime; }\r\n    public void setSmsSleepTime(long smsSleepTime) { this.smsSleepTime = smsSleepTime; }\r\n    public void setTakesLongSleepTime(long takesLongSleepTime) { this.takesLongSleepTime = takesLongSleepTime; }\r\n}\r\n",
      "info": {
        "size": 3362,
        "last_modified": "2025-12-12T15:03:50.0733092",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\auth\\AuthenticationController.java",
      "content": "package com.springqprobackend.springqpro.controller.auth;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.UserEntity;\r\nimport com.springqprobackend.springqpro.redis.RedisTokenStore;\r\nimport com.springqprobackend.springqpro.repository.UserRepository;\r\nimport com.springqprobackend.springqpro.security.*;\r\nimport com.springqprobackend.springqpro.security.dto.AuthResponse;\r\nimport com.springqprobackend.springqpro.security.dto.LoginRequest;\r\nimport com.springqprobackend.springqpro.security.dto.RefreshRequest;\r\nimport com.springqprobackend.springqpro.security.dto.RegisterRequest;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.authentication.BadCredentialsException;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.server.ResponseStatusException;\r\nimport java.util.Map;\r\n\r\n/* AuthenticationController.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nAuthentication started extremely simple  just a login endpoint returning a raw JWT.\r\nAs security needs grew (Redis-backed refresh tokens, logout, token rotation), the\r\ncontroller expanded into a full mini-authentication module.\r\n\r\n[CURRENT ROLE]:\r\nImplements:\r\n  - /auth/register\r\n  - /auth/login\r\n  - /auth/refresh (with rotation)\r\n  - /auth/logout (server-side token invalidation)\r\nBacked by:\r\n  - UserEntity + UserRepository (Postgres)\r\n  - JwtUtil (token creation/validation)\r\n  - RedisTokenStore (refresh-token persistence)\r\n  - RefreshTokenService (rotation + validation rules)\r\n[FUTURE WORK]:\r\nCloudQueue may replace this entire controller with:\r\n  - AWS Cognito\r\n  - OAuth2 identity provider\r\n  - Federated JWTs for multi-region clusters\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@RestController\r\n@RequestMapping(\"/auth\")\r\npublic class AuthenticationController {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationController.class);\r\n    private final UserRepository userRepo;\r\n    private final PasswordEncoder encoder;\r\n    private final JwtUtil jwt;\r\n    private final RedisTokenStore redis;\r\n    private final long refreshTtlMs = 3L * 24 * 60 * 60 * 1000; // 3 days is fine.\r\n\r\n    // Constructor(s):\r\n    public AuthenticationController(UserRepository userRepo, PasswordEncoder encoder, JwtUtil jwt, RedisTokenStore redis) {\r\n        this.userRepo = userRepo;\r\n        this.encoder = encoder;\r\n        this.jwt = jwt;\r\n        this.redis = redis;\r\n    }\r\n\r\n    // Method(s):\r\n    // 2025-11-25-NOTE: Now will throw ResponseStatusException(HttpStatus.CONFLICT, ...); for already-existing email. GlobalExceptionHandler now formats the JSON response.\r\n    @PostMapping(\"/register\")\r\n    public ResponseEntity<Map<String, String>> register(@RequestBody RegisterRequest req) {\r\n        if (userRepo.existsById(req.email())) {\r\n            // 409 CONFLICT is what is usually used for \"resource already exists.\"\r\n            logger.info(\"[AuthenticationController] Register attempt failed; provided email is already registered.\");\r\n            throw new ResponseStatusException(HttpStatus.CONFLICT, \"Email is already registered\");\r\n        }\r\n        String hash = encoder.encode(req.password());\r\n        logger.info(\"[AuthenticationController] Saving new UserEntity (via UserRepository.save(...))\");\r\n        userRepo.save(new UserEntity(req.email(), hash));\r\n        return ResponseEntity.status(HttpStatus.CREATED).body(Map.of(\"status\", \"registered\"));\r\n    }\r\n    // 2025-11-25-NOTE: Now will throw BadCredentialsException for invalid Login credentials. GlobalExceptionHandler now formats the JSON response.\r\n    @PostMapping(\"/login\")\r\n    public AuthResponse login(@RequestBody LoginRequest req) {\r\n        UserEntity user = userRepo.findById(req.email()).orElseThrow(() -> new BadCredentialsException(\"Invalid login credentials\"));\r\n        if(!encoder.matches(req.password(), user.getPasswordHash())) {\r\n            logger.info(\"[AuthenticationController] Login attempt failed; the password was incorrect.\");\r\n            throw new BadCredentialsException(\"Invalid credentials\");\r\n        }\r\n        logger.info(\"[AuthenticationController] Login credentials approved. Generating access and refresh tokens.\");\r\n        String access = jwt.generateAccessToken(user.getEmail());\r\n        String refresh = jwt.generateRefreshToken(user.getEmail());\r\n        logger.info(\"[AuthenticationController] Storing refresh token in RedisTokenStore.\");\r\n        redis.storeRefreshToken(refresh, user.getEmail(), refreshTtlMs);\r\n        // Return pure DTO - GlobalExceptionHandler will shape errors:\r\n        return new AuthResponse(access, refresh);\r\n    }\r\n    /* 2025-11-25-NOTE(S): refresh() now throws\r\n    - BAD_REQUEST if token is missing\r\n    - UNAUTHORIZED if redis can't find it and/or if JWT is expired.\r\n    GlobalExceptionHandler now formats the JSON response.\r\n    */\r\n    @PostMapping(\"/refresh\")\r\n    public AuthResponse refresh(@RequestBody RefreshRequest req) {\r\n        String oldRefresh = req.refreshToken();\r\n        // This first condition check here checks to see if a Token was even provided:\r\n        if (oldRefresh == null || oldRefresh.isBlank()) {\r\n            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"No refresh token provided\");\r\n        }\r\n        // Look up in Redis (source of truth for issued/rotated tokens):\r\n        String email = redis.getEmailForToken(oldRefresh);\r\n        /* This second condition check here is a bit tricky. So here's what's going on:\r\n        With the statement above this comment block, I'm checking to see if this token is currently stored in the Redis layer.\r\n        If email returns null, that -- from an outsider perspective -- will mean either the Token expired (Redis TTL could have\r\n        removed it automatically) or it didn't exist/was deleted/tampered with (and so Redis doesn't recognize it).\r\n        The message that's sent relates to this ambiguity.\r\n        */\r\n        if (email == null) {\r\n            // Could be expired from Redis TTL, never issued, or manually deleted\r\n            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, \"Invalid or expired refresh token\");\r\n        }\r\n        /* This third condition check here is still needed though because Redis isn't the \"source of truth\" (Redis only lets us\r\n        know if the Token existed at some point or that the Token hasn't yet expired in Redis). Redis, however, will NOT guarantee\r\n        whether the JWT's internal expiration claim is still valid, whether someone tampered with it externally (this is professional practice stuff),\r\n        whether the access and refresh tokens were issued together, and whether the private signing key was rotated. */\r\n        // SO ^ the condition below ACTUALLY checks to see if it's expired (because we know it's in Redis and *should* be a valid issued token:\r\n        if (jwt.isExpired(oldRefresh)) {\r\n            redis.delete(oldRefresh);\r\n            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, \"Refresh token expired\");\r\n        }\r\n        /*\r\n        Redis is the \"source of truth\" for refresh token persistence, but JWT is the source of truth for token validity.\r\n        - Redis Check is basically: Has the refresh token been issued / rotated / invalidated?\r\n        - JWT Check: Is the token cryptographically valid and still inside its lifetime?\r\n        TL;DR = expired in Redis =/= expired in JWT!\r\n        - Redis may outlive JWT expiration\r\n        - Redis TTL may be longer\r\n        - Redis time may drift\r\n        - A token may be tampered\r\n        - A token may be regenerated manually\r\n        THE TWO CHECKS PROTECT AGAINST TWO DIFFERENT FAILURE CLASSES.\r\n        */\r\n        // Invalidate old refresh token (rotation best practice)\r\n        redis.delete(oldRefresh);\r\n        String newAccess = jwt.generateAccessToken(email);\r\n        String newRefresh = jwt.generateRefreshToken(email);\r\n        redis.storeRefreshToken(newRefresh, email, refreshTtlMs);\r\n        return new AuthResponse(newAccess, newRefresh);\r\n    }\r\n\r\n    // 2025-12-03-NOTE: Adding this for a front-end thing.\r\n    @GetMapping(\"/refresh-status\")\r\n    public ResponseEntity<Map<String, Object>> refreshStatus(@RequestHeader(\"Authorization\") String authHeader, @RequestParam(\"refreshToken\") String refreshToken) {\r\n        if(authHeader == null || !authHeader.startsWith(\"Bearer \")) throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Missing Authorization header\");\r\n        if(refreshToken == null || refreshToken.isBlank()) throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"Missing refresh token\");\r\n\r\n        String accessToken = authHeader.substring(7);\r\n        String emailFromJwt = jwt.extractEmail(accessToken);\r\n        // Redis returns email if the token is active\r\n        String storedEmail = redis.getEmailForToken(refreshToken);\r\n        boolean active = (storedEmail != null && storedEmail.equals(emailFromJwt));\r\n        return ResponseEntity.ok(Map.of(\"active\", active));\r\n    }\r\n\r\n    // 2025-11-25-NOTE: ADDING THIS ENDPOINT. HAVING THIS SHOULD BE COMMONSENSE BUT IT'S ALSO GOOD FOR REFRESH TOKEN REMOVAL.\r\n    // No JWT validation here  logout is a server-side cleanup operation only. This is *apparently* exactly how Auth0, AWS Cognito, GitHub OAuth implement logout.\r\n    @PostMapping(\"/logout\")\r\n    public ResponseEntity<Map<String, String>> logout(@RequestBody RefreshRequest req) {\r\n        String refresh = req.refreshToken();\r\n        if (refresh == null || refresh.isBlank()) {\r\n            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, \"No refresh token provided\");\r\n        }\r\n        // Just delete  even if nonexistent. Logout must be idempotent.\r\n        redis.delete(refresh);\r\n        return ResponseEntity.ok(Map.of(\"status\", \"logged out\"));\r\n    }\r\n}\r\n",
      "info": {
        "size": 10129,
        "last_modified": "2025-12-12T15:03:50.0932448",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\controllerRecords.java",
      "content": "package com.springqprobackend.springqpro.controller;\r\n\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\n\r\n// NOTE: I actually don't know if this is deprecated or not or if it's used in TaskRedisController.java...\r\n/* controllerRecords.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nAs the project grew, many of the ad-hoc JSON payloads used in controllers needed structure.\r\nSpring records became the canonical way to represent immutable request DTOs. Instead of scattering\r\nsmall DTO classes across multiple files, these record definitions are collected here for easier navigation and code cleanliness.\r\n\r\n[CURRENT ROLE]:\r\nProvides strongly typed request models for:\r\n  - Login / Register flows\r\n  - Token refresh\r\n  - REST-based Task operations\r\n  - Misc GraphQL-ready helper types\r\n\r\n[FUTURE WORK]:\r\nThese records may eventually be replaced by:\r\n  - Contract-first schema generation (OpenAPI)\r\n  - GraphQL input types exclusively\r\n  - Codegen DTOs when CloudQueue adopts a gateway\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\npublic record controllerRecords() {\r\n    // public record types (mirroring the \"input\" types seen in my schema.graphqls):\r\n    public record CreateTaskInput(String payload, TaskType type) {}\r\n    public record UpdateTaskInput(String id, TaskStatus status, Integer attempts) {}\r\n}\r\n",
      "info": {
        "size": 1511,
        "last_modified": "2025-12-12T15:03:50.1115334",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\graphql\\GraphiQLRedirectController.java",
      "content": "package com.springqprobackend.springqpro.controller.graphql;\r\n\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\n\r\n@Controller\r\npublic class GraphiQLRedirectController {\r\n    @GetMapping({\"/graphiql\", \"/graphiql/\"})\r\n    public String redirect() {\r\n        return \"redirect:/graphiql/index.html\";\r\n    }\r\n}\r\n",
      "info": {
        "size": 370,
        "last_modified": "2025-12-12T15:03:50.1248596",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\graphql\\TaskGraphQLController.java",
      "content": "package com.springqprobackend.springqpro.controller.graphql;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.service.ProcessingService;\r\nimport com.springqprobackend.springqpro.service.TaskService;\r\nimport com.springqprobackend.springqpro.controller.controllerRecords.CreateTaskInput;\r\nimport com.springqprobackend.springqpro.controller.controllerRecords.UpdateTaskInput;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.graphql.data.method.annotation.Argument;\r\nimport org.springframework.graphql.data.method.annotation.MutationMapping;\r\nimport org.springframework.graphql.data.method.annotation.QueryMapping;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/* TaskGraphQLController.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nGraphQL was introduced as the modern API surface for SpringQueuePro. REST worked fine during\r\nthe prototype phase, but GraphQL gave us:\r\n  - typed schemas\r\n  - explicit input types\r\n  - streamlined task queries\r\n  - future subscription support\r\nThis controller is where that GraphQL schema becomes executable. (Honestly, I've really just\r\nwanted a reason to use GraphQL and get some experience working with it since it was a requirement\r\nfor a job position I was interviewed for but ultimately bombed).\r\n\r\n[CURRENT ROLE]:\r\nImplements GraphQL Query + Mutation resolvers for:\r\n  - task(id)\r\n  - tasks(status)\r\n  - createTask(input)\r\n  - updateTask(input)\r\n  - deleteTask(id)\r\nAll operations flow through TaskService -> QueueService/ProcessingService -> PostgreSQL.\r\n\r\nAUTH:\r\nEach resolver enforces JWT authentication before performing any operation.\r\n\r\n[FUTURE WORK]:\r\nCloudQueue could add:\r\n    subscriptions for real-time task progress\r\n    federated schemas\r\n    dedicated analytics schema for metrics\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n/* NOTE(S)-TO-SELF:\r\n- @QueryMapping is the GraphQL query resolver (to read operations / basically retrieve stuff, from what I understand).\r\n- @MutationMapping is the GraphQL mutation resolver (to write operations / to modify data basically).\r\n- @Argument maps GraphQL query args to method parameters.\r\n- The schema defines how the client *sees* the data.\r\n- Spring will automatically wire the /graphql endpoint (no controller mapping is needed).\r\n*/\r\n@Controller // IMPORTANT NOTE: GraphQL controllers use @Controller, NOT @RestController (remember this!)\r\npublic class TaskGraphQLController {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(ProcessingService.class);\r\n    private final TaskService taskService;\r\n    private final ProcessingService processingService;\r\n    // Constructor(s):\r\n    public TaskGraphQLController(TaskService taskService, ProcessingService processingService) {\r\n        this.taskService = taskService;\r\n        this.processingService = processingService;\r\n    }\r\n\r\n    // QUERIES:\r\n    @QueryMapping   // This is GraphQL query resolver.\r\n    @PreAuthorize(\"isAuthenticated()\")  // 2025-11-24-DEBUG: Securing my GraphQL resolvers for JWT.\r\n    public List<TaskEntity> tasks(@Argument TaskStatus status, Authentication auth) {\r\n        String owner = auth.getName();\r\n        logger.info(\"INFO: GraphQL 'tasks' (by status) Query sent by user:{}\", owner);\r\n        return taskService.getAllTasksForUser(status, owner);\r\n    }\r\n    @QueryMapping\r\n    @PreAuthorize(\"isAuthenticated()\")  // 2025-11-24-DEBUG: Securing my GraphQL resolvers for JWT.\r\n    public List<TaskEntity> tasksType(@Argument TaskType type, Authentication auth) {\r\n        String owner = auth.getName();\r\n        logger.info(\"INFO: GraphQL 'tasks' (by type) Query sent by user:{}\", owner);\r\n        return taskService.getAllTasksForUserByType(type, owner);\r\n    }\r\n    @QueryMapping\r\n    @PreAuthorize(\"isAuthenticated()\")  // 2025-11-24-DEBUG: Securing my GraphQL resolvers for JWT.\r\n    public TaskEntity task(@Argument String id, Authentication auth) {\r\n        String owner = auth.getName();\r\n        logger.info(\"INFO: GraphQL 'task' (by id:{}) Query sent by user:{}\", id, owner);\r\n        return taskService.getTaskForUser(id, owner).orElse(null);\r\n    }\r\n\r\n    // MUTATIONS:\r\n    @MutationMapping\r\n    //@PreAuthorize(\"isAuthenticated()\")  // 2025-11-24-DEBUG: Securing my GraphQL resolvers for JWT.\r\n    public TaskEntity createTask(@Argument(\"input\") CreateTaskInput input, Authentication auth) {\r\n        String owner = auth.getName();\r\n        logger.info(\"INFO: GraphQL 'createTask' Query sent by user:{}\", owner);\r\n        return taskService.createTaskForUser(input.payload(), input.type(), owner);\r\n    }\r\n    @MutationMapping\r\n    @Transactional\r\n    @PreAuthorize(\"isAuthenticated()\")  // 2025-11-24-DEBUG: Securing my GraphQL resolvers for JWT.\r\n    public TaskEntity updateTask(@Argument(\"input\") UpdateTaskInput input, Authentication auth) {\r\n        String owner = auth.getName();\r\n        logger.info(\"INFO: GraphQL 'updateTask' (id={}) Query sent by user:{}\", input.id(), owner);\r\n        // Ownership check (User shouldn't be allowed to update other User's tasks; no cross-user updates):\r\n        taskService.getTaskForUser(input.id(), owner).orElseThrow(() -> new RuntimeException(\"Task not found or not owned by current user.\"));\r\n        taskService.updateStatus(input.id(), input.status(), input.attempts());\r\n        return taskService.getTaskForUser(input.id(), owner).orElse(null);\r\n    }\r\n    @MutationMapping\r\n    @Transactional\r\n    @PreAuthorize(\"isAuthenticated()\")\r\n    public boolean deleteTask(@Argument String id, Authentication auth) {\r\n        String owner = auth.getName();\r\n        logger.info(\"INFO: GraphQL 'deleteTask' (id={}) Query sent by user:{}\", id, auth.getName());\r\n        if(taskService.getTaskForUser(id, owner).isEmpty()) {\r\n            return false;\r\n        }\r\n        return taskService.deleteTask(id);\r\n    }\r\n\r\n    @MutationMapping\r\n    @PreAuthorize(\"isAuthenticated()\")\r\n    public boolean retryTask(@Argument String id, Authentication auth) {\r\n        String owner = auth.getName();\r\n        logger.info(\"INFO: GraphQL 'requeueTask' (id={}) Query sent by user:{}\", id, owner);\r\n        // ownership check:\r\n        taskService.getTaskForUser(id, owner).orElseThrow(() -> new RuntimeException(\"Task not found or not owned by user.\"));\r\n        return processingService.manuallyRequeue(id);\r\n    }\r\n\r\n    /* 2025-12-04-NOTE: Adding a new method in the GraphQL Controller that exposes enums (useful for frontends\r\n    so they can parse the acceptable enums defined in schema.graphqls and avoid hardcoding values). */\r\n    @QueryMapping\r\n    @PreAuthorize(\"isAuthenticated()\")\r\n    public Map<String, List<String>> taskEnums() {\r\n        return Map.of(\r\n                \"taskTypes\", Arrays.stream(TaskType.values())\r\n                        .map(Enum::name)\r\n                        .toList(),\r\n                \"taskStatuses\", Arrays.stream(TaskStatus.values())\r\n                        .map(Enum::name)\r\n                        .toList()\r\n        );\r\n    }\r\n\r\n}\r\n",
      "info": {
        "size": 7571,
        "last_modified": "2025-12-12T15:03:50.1366346",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\rest\\ProcessingEventsController.java",
      "content": "package com.springqprobackend.springqpro.controller.rest;\r\n\r\nimport com.springqprobackend.springqpro.service.ProcessingService;\r\nimport com.springqprobackend.springqpro.service.QueueService;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/processing\")\r\n@PreAuthorize(\"isAuthenticated()\")\r\npublic class ProcessingEventsController {\r\n    // Field(s):\r\n    private final ProcessingService processing;\r\n    private final QueueService queueService;\r\n    // Constructor(s):\r\n    public ProcessingEventsController(ProcessingService processing, QueueService queueService) {\r\n        this.processing = processing;\r\n        this.queueService = queueService;\r\n    }\r\n    // Endpoints:\r\n    @GetMapping(\"/events\")\r\n    public List<String> getEvents() {\r\n        return processing.getRecentLogEvents();\r\n    }\r\n\r\n    @GetMapping(\"/workers\")\r\n    public Map<String, Integer> getWorkerStatus() {\r\n        ThreadPoolExecutor exec = queueService.getExecutor();\r\n\r\n        int active = exec.getActiveCount();\r\n        int pool = exec.getPoolSize();\r\n        int idle = pool - active;\r\n        int queue = exec.getQueue().size();\r\n\r\n        return Map.of(\r\n                \"active\", active,\r\n                \"idle\", idle,\r\n                \"inFlight\", queue\r\n        );\r\n    }\r\n}\r\n",
      "info": {
        "size": 1607,
        "last_modified": "2025-12-12T15:03:50.1545523",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\rest\\ProducerController.java",
      "content": "package com.springqprobackend.springqpro.controller.rest;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.service.QueueService;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.service.TaskService;\r\nimport jakarta.validation.Valid;\r\nimport jakarta.validation.constraints.NotBlank;\r\nimport jakarta.validation.constraints.NotNull;\r\nimport jakarta.validation.constraints.Size;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.time.Instant;\r\nimport java.util.Map;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\n/* ProducerController.java (DEPRECATED)\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]\r\nThis was the original REST API for enqueuing and inspecting in-memory Tasks during the early SpringQueue\r\nprototype phase. This was used when the queue was fully in-memory and supported these endpoints:\r\n- /api/enqueue\r\n- /api/jobs\r\n- /api/jobs/:id\r\n- /api/jobs/:id/retry\r\n\r\nAs the architecture evolved into SpringQueuePro, the Queue was no longer fully in memory and the system\r\nbecame more and more decoupled (e.g., persistence moving to PostgreSQL, distributed locking moving to Redis,\r\nand retry logic moving to ProcessingService), this controller became obsolete. Additionally, it was important\r\nfor me to integrate GraphQL into this project so it always my intention to move away from a REST-styled API.\r\n- All production logic has essentially moved to TaskGraphQLController and TaskService / ProcessingService.\r\n--------------------------------------------------------------------------------------------------\r\nKept as a historical artifact and also for legacy compatibility.\r\n- NOTE: Comments frequently reference GoQueue (recall that SpringQueue began as a logical translation\r\nof GoQueue into Java/SpringBoot and then advanced to become more \"idiomatically Java\").\r\n*/\r\n\r\n@Deprecated\r\n@RestController\r\n@RequestMapping(\"/api\")\r\n//@CrossOrigin(origins = \"${CORS_ALLOWED_ORIGIN}\") // for Netlify/Railway CORS (also local dev) <-- this line alone should replace the CORS stuff I had in Producer.go\r\npublic class ProducerController {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(ProducerController.class);\r\n    private final QueueService queue;\r\n    private final TaskService taskService;\r\n    /* NOTE: Don't need @Autowired annotation here. Explicit @Autowired is only needed for multiple constructors or setter-based injection.\r\n    -- Spring will automatically inject constructor parameters for single constructors.\r\n    -- Regarding this.queue = queue;, see comment in Worker.java class (Java is pass-by-value for objects, but that value is the reference). */\r\n    public ProducerController(QueueService queue, TaskService taskService) {\r\n        this.queue = queue;\r\n        this.taskService = taskService;\r\n    }\r\n\r\n    // 0. My GoQueue project had a struct \"type EnqueueReq struct {...}\" in its producer.go file. This would be the equivalent:\r\n    // -- This is the DOT (Data Transfer Object).\r\n    public static class EnqueueReq {\r\n        @NotBlank(message=\"Payload cannot be blank.\")\r\n        @Size(max = 1000, message=\"Payload should not exceed 1000 characters.\")\r\n        public String payload;\r\n        @NotNull(message=\"Task Type cannot be NULL.\")\r\n        public TaskType type;\r\n    }\r\n\r\n    // 1. The equivalent of GoQueue's \"http.HandleFunc(\"/api/enqueue\", func(w http.ResponseWriter, r *http.Request) {...}\" function:\r\n    /* TO-DO:+NOTE: Should probably also make one where a Task itself is directly instantiated since I added Validation Annotations to that file...\r\n    -- I guess the problem is that the EnqueueReq one is already mapped to /enqueue? Or can I add another one for it?\r\n    -- Not super high priority right now. Come back to this later and figure something out...\r\n    * */\r\n    @PostMapping(\"/enqueue\")\r\n    public ResponseEntity<Map<String, String>> handleEnqueue(@Valid @RequestBody EnqueueReq req) {\r\n        if(req.type == null) {\r\n            return ResponseEntity.badRequest().body(Map.of(\"error\", \"Task type is required.\"));\r\n        }\r\n        TaskEntity entity = taskService.createTask(req.payload, req.type);\r\n        return ResponseEntity.ok(Map.of(\"message\", String.format(\"Job %s (Payload: %s, Type: %s) enqueued! Status: %s\", entity.getId(), entity.getPayload(), entity.getType().toString(), entity.getStatus().toString())));\r\n    }\r\n\r\n    /* 2025-11-17-DEBUG: JUST SOMETHING TO UNDERSTAND -- EFFECTIVELY EVERYTHING BENEATH HERE IS LEGACY CODE.\r\n    FOR ALL OF THIS RETRIEVAL DATA, WE'RE GOING TO BE WORKING WITH GRAPHQL OR EVEN THE MIRROR REST CONTROLLER\r\n    THAT I HAVE WRITTEN AND DEFINED INSIDE THE SAME DIRECTORY. */\r\n    // EDIT: LIKE I MIGHT AS WELL SWAP IN ALL THE CODE FOR WHAT I HAVE IN TaskRestController's COUNTERPART METHODS.\r\n\r\n    // 2. The equivalent of GoQueue's \"http.HandleFunc(\"/api/jobs\", func(w http.ResponseWriter, r *http.Request) {...}\" function:\r\n    // From producer.go: \"THIS IS FOR [GET /api/jobs] and [GET /api/jobs?status=queued]\" <-- hence why we're using @RequestParam\r\n    @GetMapping(\"/jobs\")\r\n    public ResponseEntity<List<Task>> handleListJobs(@RequestParam(required = false) String status) {\r\n        //Task[] allJobs = queue.getJobs();\r\n        //List<Task> filtered = Arrays.stream(allJobs).filter(t -> t != null && (status == null || t.getStatus().toString().equalsIgnoreCase(status))).collect(Collectors.toList());\r\n        List<Task> allJobs = queue.getJobs();\r\n        logger.info(\"The value of allJobs is {} and the value of queue.getJobs() is {}\", allJobs, queue.getJobs());\r\n        List<Task> filtered = allJobs.stream().filter(t -> t != null && (status == null || t.getStatus().toString().equalsIgnoreCase(status))).collect(Collectors.toList());\r\n        return ResponseEntity.ok(filtered);\r\n    }\r\n\r\n    // The handlers below will be for the individual methods in GoQueue's \"http.HandleFunc(\"/api/jobs/\", func(w http.ResponseWriter, r *http.Request) {...}\" function:\r\n    // 3. This is for [GET /api/jobs/:id]:\r\n    @GetMapping(\"/jobs/{id}\")\r\n    public ResponseEntity<Task> handleGetJobById(@PathVariable String id) {\r\n        Task t = queue.getJobById(id);\r\n        if(t == null) return ResponseEntity.notFound().build();\r\n        return ResponseEntity.ok(t);\r\n    }\r\n\r\n    // 4. This is for [POST /api/jobs/:id/retry]:\r\n    @PostMapping(\"/jobs/{id}/retry\")\r\n    public ResponseEntity<?> handleRetryJobById(@PathVariable String id) {\r\n        Task t = queue.getJobById(id);\r\n        if(t == null) return ResponseEntity.notFound().build();\r\n        if(t.getStatus() != TaskStatus.FAILED) return ResponseEntity.badRequest().body(Map.of(\"error\", \"[Retry attempt] Can only retry failed jobs\"));\r\n\r\n        Task tClone = new Task(\r\n                \"Task-\" + System.nanoTime(),\r\n                t.getPayload(),\r\n                t.getType(),\r\n                TaskStatus.QUEUED,\r\n                0,\r\n                3,\r\n                Instant.now(),\r\n                //LocalDateTime.now()//.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"))\r\n                \"buffer-email\"  // this file is outdated!!!\r\n        );\r\n        queue.enqueue(tClone);\r\n        return ResponseEntity.ok(tClone);\r\n    }\r\n\r\n    // 5. This is for [DELETE /api/jobs/:id]\r\n    @DeleteMapping(\"/jobs/{id}\")\r\n    public ResponseEntity<?> handleDeleteJobById(@PathVariable String id) {\r\n        boolean deleteRes = queue.deleteJob(id);\r\n        if(!deleteRes) return ResponseEntity.notFound().build();\r\n        return ResponseEntity.ok(Map.of(\"message\", String.format(\"Job %s deleted!\", id)));\r\n    }\r\n    /* DEBUG:+NOTE:+TO-DO: ^ When I get to the stage where I start really expanding on the API endpoints (making this a deployable microservice),\r\n    I want to change the return value here slightly. In best practice, it's not supposed to be a 200 (OK) response, RESTful API\r\n    design has it so that what I'd do here is return 204 (No Content) sign, which would imply \"the resource was deleted successfully,\r\n    there is no further content to return.\"\r\n    DEBUG:+NOTE:+TO-DO: Re-scan over all the functions, honestly, and evaluate if my return codes are correct later. (Do some more reading into return codes, etc).\r\n    */\r\n\r\n    // 6. This is for the [POST /api/clear]\r\n    @PostMapping(\"/clear\")\r\n    public ResponseEntity<?> clearQueue() {\r\n        queue.clear();\r\n        return ResponseEntity.ok(Map.of(\"message\", \"All jobs in the queue cleared!\"));\r\n    }\r\n\r\n}\r\n",
      "info": {
        "size": 8820,
        "last_modified": "2025-12-12T15:03:50.1591268",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\rest\\SystemHealthController.java",
      "content": "package com.springqprobackend.springqpro.controller.rest;\r\n\r\nimport io.micrometer.core.instrument.Counter;\r\nimport io.micrometer.core.instrument.DistributionSummary;\r\nimport io.micrometer.core.instrument.Gauge;\r\nimport io.micrometer.core.instrument.MeterRegistry;\r\nimport org.springframework.boot.actuate.health.*;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.util.LinkedHashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.TimeUnit;\r\nimport io.micrometer.core.instrument.Timer;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/internal\")\r\n@PreAuthorize(\"isAuthenticated()\")\r\npublic class SystemHealthController {\r\n\r\n    private final HealthEndpoint health;      // returns Map-style JSON (always works)\r\n    private final MeterRegistry registry;\r\n\r\n    public SystemHealthController(HealthEndpoint health, MeterRegistry registry) {\r\n        this.health = health;\r\n        this.registry = registry;\r\n    }\r\n\r\n    // -----------------------------\r\n    // 1) Return Actuator health JSON\r\n    // -----------------------------\r\n    @GetMapping(\"/health\")\r\n    public Map<String, Object> getHealth() {\r\n        HealthComponent hc = health.health();\r\n\r\n        Map<String, Object> out = new LinkedHashMap<>();\r\n        out.put(\"status\", hc.getStatus().getCode());\r\n\r\n        if (hc instanceof CompositeHealth composite) {\r\n            Map<String, Object> sub = new LinkedHashMap<>();\r\n            composite.getComponents().forEach((name, comp) -> {\r\n                sub.put(name, Map.of(\r\n                        \"status\", comp.getStatus().getCode()\r\n                ));\r\n            });\r\n            out.put(\"components\", sub);\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    // -----------------------------\r\n    // 2) Return simple metric values\r\n    // -----------------------------\r\n    @GetMapping(\"/metric/{name}\")\r\n    public Map<String, Object> getMetric(@PathVariable String name) {\r\n\r\n        // Try Gauge\r\n        Gauge g = registry.find(name).gauge();\r\n        if (g != null) {\r\n            return Map.of(\r\n                    \"name\", name,\r\n                    \"type\", \"gauge\",\r\n                    \"value\", g.value()\r\n            );\r\n        }\r\n\r\n        // Try Timer\r\n        io.micrometer.core.instrument.Timer t = registry.find(name).timer();\r\n        if (t != null) {\r\n            return Map.of(\r\n                    \"name\", name,\r\n                    \"type\", \"timer\",\r\n                    \"totalMs\", t.totalTime(TimeUnit.MILLISECONDS),\r\n                    \"count\", t.count(),\r\n                    \"meanMs\", t.mean(TimeUnit.MILLISECONDS)\r\n            );\r\n        }\r\n\r\n        // Fallback\r\n        return Map.of(\r\n                \"name\", name,\r\n                \"type\", \"unknown\",\r\n                \"value\", null\r\n        );\r\n    }\r\n}\r\n",
      "info": {
        "size": 2835,
        "last_modified": "2025-12-12T15:03:50.1726354",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\controller\\rest\\TaskRestController.java",
      "content": "package com.springqprobackend.springqpro.controller.rest;\r\n/* NOTE: This file is primarily included for the purpose of practice, and also I guess \"mirror testing.\"\r\nThis is just a REST Controller that one-to-one mimics the purpose of my GraphQL Controller.\r\n(That's also why I have -- at least currently -- have it in the /graphql package directory).\r\n*/\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.service.TaskService;\r\nimport com.springqprobackend.springqpro.controller.controllerRecords.CreateTaskInput;\r\nimport com.springqprobackend.springqpro.controller.controllerRecords.UpdateTaskInput;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\nimport java.util.List;\r\n\r\n/* TaskRestController.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nThis controller was created as a REST mirror of the GraphQL controller for debugging,\r\neducational purposes, and Postman-based testing. While GraphQL is the official API,\r\nREST endpoints remain extremely useful when verifying behavior with simple clients.\r\n\r\n[CURRENT ROLE]:\r\nProvides REST-style CRUD endpoints for persisted Tasks. Mainly used for:\r\n  - debugging\r\n  - regression testing\r\n  - side-by-side comparison with GraphQL\r\n  - my own learning tbh\r\nProduction usage will happen through GraphQL.\r\n\r\n[FUTURE WORK]:\r\nIn CloudQueue, REST may be removed or replaced with:\r\n    gateway-exposed read endpoints\r\n    admin-only REST management routes\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@RestController\r\n@RequestMapping(\"/api/tasks\")\r\npublic class TaskRestController {\r\n    // Field(s):\r\n    private TaskService taskService;\r\n    // Constructor(s):\r\n    public TaskRestController(TaskService taskService) { this.taskService = taskService; }\r\n\r\n    @GetMapping(\"/jobs\")\r\n    public List<TaskEntity> tasks(@RequestParam(required = false) TaskStatus status) {\r\n        return taskService.getAllTasks(status);\r\n    }\r\n\r\n    @GetMapping(\"/jobs/{id}\")\r\n    public ResponseEntity<TaskEntity> task(@PathVariable String id) {\r\n        return taskService.getTask(id).map(ResponseEntity::ok).orElse(ResponseEntity.notFound().build());\r\n    }\r\n\r\n    @PostMapping(\"/create\")\r\n    public TaskEntity createTask(@RequestBody CreateTaskInput input) {\r\n        return taskService.createTask(input.payload(), input.type());\r\n    }\r\n\r\n    @PatchMapping(\"/update/{id}\")\r\n    public ResponseEntity<TaskEntity> updateTask(@PathVariable String id, @RequestBody UpdateTaskInput input) {\r\n        taskService.updateStatus(id, input.status(), input.attempts());\r\n        return taskService.getTask(id).map(ResponseEntity::ok).orElse(ResponseEntity.notFound().build());\r\n    }\r\n\r\n    @DeleteMapping(\"/delete/{id}\")\r\n    public ResponseEntity<Void> deleteTask(@PathVariable String id) {\r\n        if (taskService.deleteTask(id)) return ResponseEntity.noContent().build();\r\n        return ResponseEntity.notFound().build();\r\n    }\r\n}\r\n",
      "info": {
        "size": 3173,
        "last_modified": "2025-12-12T15:03:50.1864023",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\domain\\entity\\TaskEntity.java",
      "content": "package com.springqprobackend.springqpro.domain.entity;\r\n\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport jakarta.persistence.*;\r\n\r\nimport java.time.Instant;\r\n\r\n/* TaskEntity.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nOriginally the system used only the in-memory Task model, held inside QueueService. As the\r\narchitecture evolved into something durable and distributed, we needed a persistent record of\r\nTasks. Thats how TaskEntity was born  the canonical database-backed form.\r\n\r\nIt gained fields like attempts, maxRetries, createdAt, and @Version to support optimistic locking.\r\nEventually it became the authoritative representation used by ProcessingService.\r\n\r\n[CURRENT ROLE]:\r\nTaskEntity is the storage-level representation of a queued job. It is used for:\r\n    Durable task state in PostgreSQL\r\n    Optimistic locking (via @Version)\r\n    Claims and transitions (QUEUED  INPROGRESS  COMPLETED/FAILED)\r\n    Integration with Redis locks\r\n    Dashboard + GraphQL queries\r\n\r\nThis is now the backbone object of the queue system.\r\n\r\n[FUTURE WORK]:\r\nCloudQueue may extend this entity to support:\r\n    priority queues\r\n    scheduled tasks (delayUntil timestamps)\r\n    multi-tenant sharding (tenantId, region)\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n// 2025-11-30-NOTE: Need to preserve the two comment blocks below for eventual documentation.\r\n/* NOTE(S)-TO-SELF:\r\n- @Entity marks this class for persistence (Hibernate will map it to a DataBase table). Each field corresponds to a column.\r\n- ^ will assume same table name, but you can specify with @Table(name=\"tasks\") <-- good practice for table names is all lowercase.\r\n- @Id obv defines the primary key.\r\n- @Enumrated stores enum names (like \"QUEUED\") instead of integers.\r\n- @Column controls SQL column behavior (type, name).\r\n- Var \"Instant\" is preferred for timestamps over \"LocalDateTime\" (UTC-Friendly).\r\nSpring Boot w/ Spring Data JPA, through Hibernate, automatically generates the SQL schema and performs CRUD operations.\r\n\r\nAlso, this file isn't meant to re-place Task.java (which stands as the runtime / in-memory representation of a Task).\r\nThis TaskEntity file here is the persistence representation (database-backed model for durable storage).\r\n*/\r\n/* NOTE(S)-TO-SELF - [PART TWO - 2025-11-13 EDITS]:\r\n- The @Version annotation is a JPA annotation for \"optimistic locking\" -- a mechanism to prevent concurrent modifications\r\nto the same entity in a database (this is for data integrity in multi-user environments).\r\n- I'm working on Persistence Validation at the moment (making sure that changes to my in-memory Tasks via QueueService\r\ne.g., Task's status goes from QUEUED -> INPROGRESS -> COMPLETED is persisted to the DataBase storage end (this is not yet implemented).\r\n- You put @Version over a Long/Integer field to basically identify the version of the entity it's placed on.\r\n\r\n[Explanation on why this is required / the race condition concern in my application wrt persisting data]:\r\nIn my project right now, I've got two separate layers of concurrency:\r\n1. Application-level Concurrency (my QueueService in-memory stuff, what I started off with)\r\n- My ExecutorService (worker threads) takes tasks off of the in-memory queue and processes them concurrently.\r\nThis part is well-contained and deterministic in memory. (Tasks are mapped to specific Workers for handling, logic is fine).\r\n2. Persistence-level Concurrency (JPA, DB stuff, etc.)\r\n- Basically, there's a possibility that these same threads could try to update and persist TaskEntity rows in the database\r\nand those attempts might overlap in time (multiple threads/workers interacting with the same persistent record at once -- that\r\nis a Persistence Race Condition).\r\n\r\n^ Yes, it's not a particularly common concern; the way my system is set up, it's rare that something like this could happen.\r\nMy project design has it so that each Task is taken and \"owned\" (during processing) by one Worker Thread at a time (that's the whole dequeue system).\r\nThat makes it so that it's pretty unlikely there will be two threads will modify the same task simultaneously; ExecutorService takes care of most race conditions.\r\nBUT --- IT CAN STILL HAPPEN (particularly externally with tools like Postman, GraphiQL, and so on).\r\n\r\nPersistence race conditions can still happen in the event of:\r\n- You have retries or resubmissions that cause overlapping updates for the same Task (identified by TaskID ofc).\r\n- A user action via Postman, GraphiQL, and so on, changes the task as its being processed.\r\n- I eventually add background database syncs or monitoring that touches tasks concurrently.\r\n\r\nHandling this with @Version etc is the way that real Job Queue systems like SideKiq, Celery, and so on do it -- so I will too!!!\r\n*/\r\n@Entity\r\n@Table(name=\"tasks\")\r\npublic class TaskEntity {\r\n    @Id\r\n    @Column(nullable = false, updatable = false)\r\n    private String id;\r\n\r\n    @Column(columnDefinition=\"text\")    // Allows long payloads\r\n    private String payload;\r\n\r\n    @Enumerated(EnumType.STRING)    // Store enum as readable string (as opposed to numeric).\r\n    @Column(nullable = false)\r\n    private TaskType type;\r\n\r\n    @Enumerated(EnumType.STRING)\r\n    @Column(nullable = false)\r\n    private TaskStatus status;\r\n\r\n    @Column(nullable = false)\r\n    private int attempts;\r\n    @Column(nullable = false)\r\n    private int maxRetries;\r\n\r\n    @Column(name=\"created_at\")  // custom DataBase column name.\r\n    private Instant createdAt;\r\n\r\n    // 2025-11-25-NOTE: Enforcing JWT User Ownership - this implementation is key!\r\n    @Column(name = \"created_by\", nullable=false, length = 255)\r\n    private String createdBy;\r\n\r\n    // Optimistic locking field (protects against lost updates):\r\n    // 2025-11-25-NOTE: This is probably outdated at this point but I'll leave it for the future cleanup down the line.\r\n    @Version\r\n    private Long version;\r\n\r\n    // NOTE: Hibernate needs a no-args constructor. Think about using \"protected\" for all of these in the future tbh.\r\n    protected TaskEntity() {}\r\n    // Constructor:\r\n    public TaskEntity(String id, String payload, TaskType type, TaskStatus status, int attempts, int maxRetries, Instant createdAt) {\r\n        this.id = id;\r\n        this.payload = payload;\r\n        this.type = type;\r\n        this.status = status;\r\n        this.attempts = attempts;\r\n        this.maxRetries = maxRetries;\r\n        this.createdAt = createdAt;\r\n    }\r\n    // EDIT:+DEBUG: Maybe this will be helpful - Constructor that'll also set createdBy:\r\n    public TaskEntity(String id, String payload, TaskType type, TaskStatus status, int attempts, int maxRetries, Instant createdAt, String createdBy) {\r\n        this(id, payload, type, status, attempts, maxRetries, createdAt);\r\n        this.createdBy = createdBy;\r\n    }\r\n\r\n    // JPA will use the getter and setter methods to map to the table columns:\r\n    // getters:\r\n    public String getId() { return id; }\r\n    public String getPayload() { return payload; }\r\n    public TaskType getType() { return type; }\r\n    public TaskStatus getStatus() { return status; }\r\n    public int getAttempts() { return attempts; }\r\n    public int getMaxRetries() { return maxRetries; }\r\n    public Instant getCreatedAt() { return createdAt; }\r\n    public Long getVersion() { return version; }\r\n    public String getCreatedBy() { return createdBy; }\r\n    // setters:\r\n    public void setId(String id) { this.id = id; }\r\n    public void setPayload(String payload) { this.payload = payload; }\r\n    public void setType(TaskType type) { this.type = type; }\r\n    public void setStatus(TaskStatus status) { this.status = status; }\r\n    public void setAttempts(int attempts) { this.attempts = attempts; }\r\n    public void setMaxRetries(int maxRetries) { this.maxRetries = maxRetries; }\r\n    public void setCreatedAt(Instant createdAt) { this.createdAt = createdAt; }\r\n    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }\r\n}\r\n",
      "info": {
        "size": 8179,
        "last_modified": "2025-12-12T15:03:50.2121918",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\domain\\entity\\UserEntity.java",
      "content": "package com.springqprobackend.springqpro.domain.entity;\r\n\r\nimport jakarta.persistence.Column;\r\nimport jakarta.persistence.Entity;\r\nimport jakarta.persistence.Id;\r\nimport jakarta.persistence.Table;\r\n\r\n/* UserEntity.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nUserEntity was added once SpringQueuePro matured past the prototype stage and required actual\r\nauthentication boundaries. Initially, the system had no concept of users; all endpoints were\r\nopen and unauthenticated.\r\n\r\nWhen JWT-based security was introduced, a persistent representation of a user (email + hashed\r\npassword) was needed. This JPA entity serves as the storage model for authentication.\r\n\r\n[CURRENT ROLE]:\r\nSimple PostgreSQL-backed entity containing:\r\n  - email (Primary Key)\r\n  - passwordHash\r\n\r\nUsed by CustomUserDetailsService and AuthenticationController for:\r\n  - login\r\n  - registration\r\n  - refresh token workflow\r\n  - token validation\r\n\r\n[FUTURE WORK]:\r\nIn CloudQueue, this may grow fields such as:\r\n  - roles / RBAC permissions\r\n  - created timestamps\r\n  - integration with AWS Cognito / OAuth providers\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n/* 2025-11-24-NOTE(S):+DEBUG: JWT INTEGRATION PHASE!!!\r\nOf course, this will be the Model representation for like a \"User Account\" I guess. (Still not 100% sure how I want to go about this).\r\n*/\r\n@Entity\r\n@Table(name=\"users\")\r\npublic class UserEntity {\r\n    @Id\r\n    @Column(nullable=false, unique=true)\r\n    private String email;\r\n\r\n    @Column(nullable=false)\r\n    private String passwordHash;\r\n\r\n    @Column(nullable=false)\r\n    private String role = \"USER\"; // USER or ADMIN\r\n\r\n    public UserEntity() {}\r\n\r\n    public UserEntity(String email, String passwordHash) {\r\n        this.email = email;\r\n        this.passwordHash = passwordHash;\r\n    }\r\n\r\n    public String getEmail() { return email; }\r\n    public String getPasswordHash() { return passwordHash; }\r\n    public String getRole() { return role; }\r\n\r\n    public void setEmail(String email) { this.email = email; }\r\n    public void setPasswordHash(String passwordHash) { this.passwordHash = passwordHash; }\r\n    public void setRole(String role) { this.role = role; }\r\n}\r\n",
      "info": {
        "size": 2292,
        "last_modified": "2025-12-12T15:03:50.2247415",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\domain\\event\\TaskCreatedEvent.java",
      "content": "package com.springqprobackend.springqpro.domain.event;\r\n\r\n// DEBUG:+NOTE:+TO-DO: Maybe merge this and the other records file I have for the GraphQL stuff.\r\n\r\n// 2025-11-13-EDIT: This record will be \"published\" by Task after saving a new task.\r\npublic record TaskCreatedEvent(Object source, String taskId) { }\r\n",
      "info": {
        "size": 310,
        "last_modified": "2025-12-12T15:03:50.2418308",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\domain\\exception\\TaskProcessingException.java",
      "content": "package com.springqprobackend.springqpro.domain.exception;\r\n\r\n/* TaskProcessingException.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nIntroduced when ProcessingService took over all retry + failure management.\r\nHandlers were no longer allowed to modify Task state directly, so the only way\r\na handler could express this task failed was by throwing an exception.\r\n\r\nThis exception formalizes that communication channel.\r\n\r\n[CURRENT ROLE]:\r\nUsed by TaskHandlers to signal processing failure. ProcessingService catches it\r\nand performs:\r\n  - FAILED state transition\r\n  - retry scheduling (if applicable)\r\n  - metrics emission\r\n  - logging + observability events\r\n\r\n[FUTURE WORK]:\r\nMay be expanded into:\r\n  - typed failure codes\r\n  - permanent vs transient failure categories\r\n  - handler-specific metadata\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\npublic class TaskProcessingException extends RuntimeException {\r\n    public TaskProcessingException(String message) {\r\n        super(message);\r\n    }\r\n    public TaskProcessingException(String message, Throwable cause) { super(message, cause); }\r\n}\r\n",
      "info": {
        "size": 1239,
        "last_modified": "2025-12-12T15:03:50.2636232",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\enums\\TaskStatus.java",
      "content": "package com.springqprobackend.springqpro.enums;\r\n\r\npublic enum TaskStatus {\r\n    QUEUED,\r\n    INPROGRESS,\r\n    COMPLETED,\r\n    FAILED,\r\n}\r\n",
      "info": {
        "size": 139,
        "last_modified": "2025-12-12T15:03:50.2915762",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\enums\\TaskType.java",
      "content": "package com.springqprobackend.springqpro.enums;\r\n\r\npublic enum TaskType {\r\n    EMAIL,\r\n    REPORT,\r\n    DATACLEANUP,\r\n    SMS,\r\n    NEWSLETTER,\r\n    TAKESLONG,\r\n    FAIL,\r\n    FAILABS,\r\n    TEST\r\n}\r\n",
      "info": {
        "size": 199,
        "last_modified": "2025-12-12T15:03:50.2950928",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\DataCleanUpHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"DATACLEANUP\")\r\npublic class DataCleanUpHandler implements TaskHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(DataCleanUpHandler.class);\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public DataCleanUpHandler(Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException {\r\n        sleeper.sleep(props.getDataCleanUpSleepTime());\r\n        logger.info(\"Task {} (Type: {}) completed\", task.getId(), task.getType());\r\n    }\r\n}\r\n",
      "info": {
        "size": 992,
        "last_modified": "2025-12-12T15:03:50.3125043",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\DefaultHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"DEFAULT\")\r\npublic class DefaultHandler implements TaskHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(DefaultHandler.class);\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public DefaultHandler(Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException {\r\n        logger.info(\"[Worker] No specific handler found for type '{}'. Executing default behavior.\", task.getType());\r\n        sleeper.sleep(props.getDefaultSleepTime());\r\n        logger.info(\"Task {} (Type: {}) completed\", task.getId(), task.getType());\r\n    }\r\n}\r\n",
      "info": {
        "size": 1089,
        "last_modified": "2025-12-12T15:03:50.3268736",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\EmailHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"EMAIL\")\r\npublic class EmailHandler implements TaskHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(EmailHandler.class);\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public EmailHandler(Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException {\r\n        sleeper.sleep(props.getEmailSleepTime());\r\n        logger.info(\"Task {} (Type: {}) completed\", task.getId(), task.getType());\r\n    }\r\n}\r\n",
      "info": {
        "size": 962,
        "last_modified": "2025-12-12T15:03:50.3268736",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\FailAbsHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.domain.exception.TaskProcessingException;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.service.QueueService;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"FAILABS\")\r\npublic class FailAbsHandler implements TaskHandler {\r\n    // Field\r\n    private static final Logger logger = LoggerFactory.getLogger(FailAbsHandler.class);\r\n    private final QueueService queue;\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public FailAbsHandler(@Lazy QueueService queue, Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.queue = queue;\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException, TaskProcessingException {\r\n        // 2025-11-15-DEBUG: As of the ProcessingService.java-related architectural overhaul, Handlers no longer manually change state.\r\n        sleeper.sleep(props.getFailAbsSleepTime());\r\n        logger.warn(\"Task {} (Type: FAILABS - Fail-Absolute) failed! Retrying...\", task.getId());\r\n        throw new TaskProcessingException(\"Intentional fail for retry simulation\");\r\n    }\r\n}\r\n",
      "info": {
        "size": 1541,
        "last_modified": "2025-12-12T15:03:50.3507796",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\FailHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.domain.exception.TaskProcessingException;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.service.QueueService;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.stereotype.Component;\r\nimport java.util.Random;\r\n\r\n@Component(\"FAIL\")\r\npublic class FailHandler implements TaskHandler {\r\n    // Field\r\n    private static final Logger logger = LoggerFactory.getLogger(FailHandler.class);\r\n    private final QueueService queue;\r\n    private final Sleeper sleeper;\r\n    private final Random random;\r\n    private final TaskHandlerProperties props;\r\n\r\n    @Autowired\r\n    public FailHandler(@Lazy QueueService queue, Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.queue = queue;\r\n        this.sleeper = sleeper;\r\n        this.random = new Random(); // This is the constructor called by Worker.java, it just uses default Random init.\r\n        this.props = props;\r\n    }\r\n\r\n    // This is the for-testing constructor where random is provided by user (to control testing outcomes, see: FailHandlerTests.java):\r\n    public FailHandler(@Lazy QueueService queue, Sleeper sleeper, Random random, TaskHandlerProperties props) {\r\n        this.queue = queue;\r\n        this.sleeper = sleeper;\r\n        this.random = random;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException, TaskProcessingException {\r\n        double successChance = 0.25;\r\n        if(random.nextDouble() <= successChance) {\r\n            sleeper.sleep(props.getFailSuccSleepTime());\r\n            logger.info(\"Task {} (Type: FAIL - 0.25 success rate on retry) completed\", task.getId());\r\n        } else {\r\n            // 2025-11-15-DEBUG: As of the ProcessingService.java-related architectural overhaul, Handlers no longer manually change state.\r\n            sleeper.sleep(props.getFailSleepTime());\r\n            logger.warn(\"Task {} (Type: FAIL - 0.25 success rate on retry) failed! Retrying...\", task.getId());\r\n            throw new TaskProcessingException(\"Intentional fail for retry simulation\");\r\n        }\r\n    }\r\n}\r\n",
      "info": {
        "size": 2471,
        "last_modified": "2025-12-12T15:03:50.3605553",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\NewsLetterHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"NEWSLETTER\")\r\npublic class NewsLetterHandler implements TaskHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(NewsLetterHandler.class);\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public NewsLetterHandler(Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException {\r\n        sleeper.sleep(props.getNewsLetterSleepTime());\r\n        logger.info(\"Task {} (Type: {}) completed\", task.getId(), task.getType());\r\n    }\r\n}\r\n",
      "info": {
        "size": 987,
        "last_modified": "2025-12-12T15:03:50.3705906",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\ReportHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"REPORT\")\r\npublic class ReportHandler implements TaskHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(ReportHandler.class);\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public ReportHandler(Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException {\r\n        sleeper.sleep(props.getReportSleepTime());\r\n        logger.info(\"Task {} (Type: {}) completed\", task.getId(), task.getType());\r\n    }\r\n}\r\n",
      "info": {
        "size": 967,
        "last_modified": "2025-12-12T15:03:50.3765259",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\SmsHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"SMS\")\r\npublic class SmsHandler implements TaskHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(SmsHandler.class);\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public SmsHandler(Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException {\r\n        sleeper.sleep(props.getSmsSleepTime());\r\n        logger.info(\"Task {} (Type: {}) completed\", task.getId(), task.getType());\r\n    }\r\n}\r\n",
      "info": {
        "size": 952,
        "last_modified": "2025-12-12T15:03:50.3922468",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\TakesLongHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"TAKESLONG\")\r\npublic class TakesLongHandler implements TaskHandler {\r\n    private static final Logger logger = LoggerFactory.getLogger(TakesLongHandler.class);\r\n    private final Sleeper sleeper;\r\n    private final TaskHandlerProperties props;\r\n\r\n    public TakesLongHandler(Sleeper sleeper, TaskHandlerProperties props) {\r\n        this.sleeper = sleeper;\r\n        this.props = props;\r\n    }\r\n\r\n    @Override\r\n    public void handle(Task task) throws InterruptedException {\r\n        sleeper.sleep(props.getTakesLongSleepTime());\r\n        logger.info(\"Task {} (Type: {}) completed\", task.getId(), task.getType());\r\n    }\r\n}\r\n",
      "info": {
        "size": 982,
        "last_modified": "2025-12-12T15:03:50.4022775",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\handlers\\TaskHandler.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\nimport com.springqprobackend.springqpro.models.Task;\r\n\r\n/* TaskHandler.java\r\n--------------------------------------------------------------------------------------------------\r\nThis is the Interface implemented by all of my Task Handlers, all of which need to define and flesh\r\nout the following operation: \"void handle(Task task) throws Exception\".\r\n\r\n[HISTORY]\r\nDuring the prototype \"base-level\" SpringQueue project, there was no interface and every Handler was a\r\ntightly coupled individual file that would change Task status (e.g., QUEUED -> INPROGRESS -> COMPLETED)\r\nthemselves and invoke retry() themselves if necessary. This was changed to use an interface for modularity\r\nand to decouple functionality (the actual handlers are quite primitive, it's designed to be reworked).\r\n\r\nAt this point, they're more like simulate worktime vessels as ProcessingService handles all persistence updates,\r\nretries, metrics, and state transitions.\r\n\r\n[SPECIAL NOTE]:\r\nThe FAIL handler family simulates intentional failure/retry scenarios.\r\n\r\n[FUTURE WORK]:\r\n- In CloudQueue, all the handlers will probably be replaced by microservices or remote workers.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n// 2025-11-30-NOTE: Save this large comment block below for my overall README.md (and probably my detailed \"phases\" section too).\r\n/* NOTE: Remember that my end goal for this whole SpringQueue(->SpringQueuePro->CloudQueue) project is for it\r\nto eventually be deployed on the cloud.\r\n\r\nIn my Worker.java class, I have a large switch-case block that handles different tasks. That was fine for my\r\nSpringQueue and GoQueue prototype, but it's brittle and better to change that to a pluggable handler pattern for SpringQueuePro.\r\nSo, that's basically going to be this TaskHandler interface that gets implemented by specific handlers for each job type.\r\n(For instance, I'll have @Component(\"EMAIL\") EmailHandler be a class that implements TaskHandler). This is better for modularity too since\r\nmy choices for actual job types e.g., email were extremely arbitrary and I will probably end up changing a lot of them later on.\r\n-- All of them are basically the same right now... (near identical func each time) but this might change as the project advances,\r\nwhich is another reason why adopting this approach is good.\r\n-- So each implementation of the TaskHandler interface will be a @Component, these handler classes will be wired into\r\na Map<String,TaskHandler> variable inside Worker automatically by Spring. (So, extending on the last bullet point, adding new task types\r\nis as easy as just adding a new @Component class.\r\n\r\nMore benefits of this choice:\r\n- O(1) extension (better than switch/case efficiency wise).\r\n- Independent testing of each task handler.\r\n- Cleaner separation of concerns! (This is important).\r\nSee comment block in TaskHandlerRegistry.java.\r\n*/\r\npublic interface TaskHandler {\r\n    void handle(Task task) throws InterruptedException;\r\n}\r\n",
      "info": {
        "size": 3065,
        "last_modified": "2025-12-12T15:03:50.4124216",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\listeners\\TaskCreatedListener.java",
      "content": "package com.springqprobackend.springqpro.listeners;\r\n\r\nimport com.springqprobackend.springqpro.domain.event.TaskCreatedEvent;\r\nimport com.springqprobackend.springqpro.service.QueueService;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.transaction.event.TransactionPhase;\r\nimport org.springframework.transaction.event.TransactionalEventListener;\r\n\r\n@Component\r\npublic class TaskCreatedListener {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(TaskCreatedListener.class);\r\n    private final QueueService queueService;\r\n    // Constructor(s):\r\n    public TaskCreatedListener(QueueService queueService) {\r\n        this.queueService = queueService;\r\n    }\r\n    // Runs only after the creating transaction commits - prevents enqueu-before commit races:\r\n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\r\n    public void onTaskCreated(TaskCreatedEvent ev) {\r\n        logger.info(\"[TaskCreatedListener] received event for {}\", ev.taskId());\r\n        queueService.enqueueById(ev.taskId());\r\n        logger.info(\"[TaskCreatedListener] enqueuedById {}\", ev.taskId());\r\n    }\r\n}\r\n",
      "info": {
        "size": 1218,
        "last_modified": "2025-12-12T15:03:50.4237171",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\mapper\\TaskMapper.java",
      "content": "package com.springqprobackend.springqpro.mapper;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport java.time.Instant;\r\n\r\n/* TaskMapper.java\r\n--------------------------------------------------------------------------------------------------\r\nThis file is responsible for converting between TaskEntity (DataBase persistent representation)\r\nand Task (in-memory domain object that the Handlers consume and process). It's this file that\r\nhelps enforce domain consistency (Handlers operate strictly on domain objects, never on persistence-layer\r\nentities). I originally just did the conversation in method with new Task object creation, but this logic\r\nneeded to be duplicated as ProcessingService came into the picture, so modularity was necessary.\r\n\r\n[FUTURE WORK]:\r\nCloudQueue might introduce additional DTOs for remote workers and built-in serialization for distributed execution.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n// 2025-11-30-NOTE: Preserving the comment below for now...\r\n/* 2025-11-15-DEBUG:+NOTE(S)-TO-SELF:\r\nThis file is primarily to avoid doing TaskEntity -> Task conversion and so on within ProcessingService.java (decoupling purposes).\r\nRemember, Handlers should be operating on Domain objects (Task) and not Persistence objects (TaskEntity).\r\nThis is just fundamental DDD principle: Repositories return Entities/Records and Business Logic consumes Domain Models.\r\n-- Persistence concerns should NOT leak into Handlers! And so we have this file here. (Handlers should NOT take TaskEntity).\r\n*/\r\n@Component\r\npublic class TaskMapper {\r\n    // TaskEntity -> Task conversion method. (Convert persistence-layer TaskEntity into a pure domain Task model).\r\n    public Task toDomain(TaskEntity e) {\r\n        if(e == null) return null;\r\n        return new Task(\r\n                e.getId(),\r\n                e.getPayload(),\r\n                e.getType(),\r\n                e.getStatus(),\r\n                e.getAttempts(),\r\n                e.getMaxRetries(),\r\n                e.getCreatedAt(),\r\n                e.getCreatedBy()\r\n        );\r\n    }\r\n    // Reconciles Domain (Task) -> TaskEntity after handler completes.\r\n    public void updateEntity(Task domain, TaskEntity entity) {\r\n        if(domain == null | entity == null) return;\r\n        entity.setPayload(domain.getPayload());\r\n        entity.setType(domain.getType());\r\n        entity.setStatus(domain.getStatus());\r\n        entity.setAttempts(domain.getAttempts());\r\n        entity.setMaxRetries(domain.getMaxRetries());\r\n        entity.setCreatedAt(Instant.parse(domain.getCreatedAt()));\r\n        entity.setCreatedBy(domain.getCreatedBy());\r\n    }\r\n}\r\n",
      "info": {
        "size": 2814,
        "last_modified": "2025-12-12T15:03:50.463881",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\models\\Task.java",
      "content": "package com.springqprobackend.springqpro.models;\r\n\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\n\r\nimport java.time.Instant;\r\nimport java.util.Objects;\r\nimport java.time.LocalDateTime;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonInclude;\r\nimport jakarta.validation.constraints.*;\r\n\r\n/* NOTE:+2025-11-05-EDIT: I'm going to be adding Validation Annotations (Bean Validation) to this file.\r\nThe purpose is to basically guard against malformed input (primarily those received at Controller endpoints).\r\n-- Controller endpoints would be marked with @Valid annotations on the @RequestBody (so stuff w/ NULL values, and so on, would be rejected ASAP).\r\n-- My existing GlobalExceptionHandler can catch MethodArgumentNotValidException errors and return clean 400s with field-specific error messages.\r\nIMPORTANT-NOTE: These validations won't auto-validate by themselves (like I can still create new Task(); without providing arguments and\r\neverything would be fine. Validation happens when you explicitly call a Validator or if Spring MVC auto triggers validation with\r\nlike @Valid on a @RequestBody argument (the latter is more what I would be working with).\r\n*/\r\n// NOTE: ^ With these inclusions, GlobalExceptionHandler.java can be updated to handle Validation errors also (hence the \"message\"s).\r\n\r\n@JsonInclude(JsonInclude.Include.NON_NULL)  // This annotation basically says no NULL fields allowed in JSON responses.\r\npublic class Task {\r\n    // Fields:\r\n    @NotBlank(message=\"Task ID cannot be blank.\")\r\n    private String id;\r\n\r\n    @NotBlank(message=\"Payload cannot be blank.\")   // DEBUG: At least for now? Maybe there's some that could? I don't know.\r\n    @Size(max = 1000, message=\"Payload should not exceed 1000 characters.\") // DEBUG: I think that's a good limit? Adjust later.\r\n    private String payload;\r\n\r\n    @NotNull(message=\"Task Type cannot be NULL.\")\r\n    private TaskType type;    // TO-DO:(?) I could change this to also be an enum like \"status\" (not sure how undefined/foreign request types are handled though).\r\n    //@NotNull(message=\"Task Status cannot be NULL.\") // <-- DEBUG: At least, I'm pretty sure. (WAIT NO -- Worker is meant to set this!!!)\r\n    private TaskStatus status;\r\n\r\n    @Min(value = 0, message=\"Attempts must be a non-negative integer value.\")\r\n    private int attempts;\r\n    @Min(value = 0, message=\"Max retries must be a non-negative integer value.\")\r\n    private int maxRetries;\r\n\r\n    @PastOrPresent(message=\"Creation Time Stamp cannot be in the future.\")\r\n    private Instant createdAt;   // TO-DO:(?) I format this with LocalDateTime. (I could change this to that type for better filtering and so on).\r\n\r\n    @NotBlank(message=\"Task owner cannot be blank.\")\r\n    private String createdBy;\r\n\r\n    // Constructor(s):\r\n    // no-args Constructor - for potential frameworks like Jackson/JPA (that may serialize/deserialize the object):\r\n    public Task() {}\r\n    // Main Constructor:\r\n    public Task(String id, String payload, TaskType type, TaskStatus status, int attempts, int maxRetries, Instant createdAt, String createdBy) {\r\n        this.id = id;\r\n        this.payload = payload;\r\n        this.type = type;\r\n        this.status = status;\r\n        this.attempts = attempts;\r\n        this.maxRetries = maxRetries;\r\n        this.createdAt = createdAt;\r\n        this.createdBy = createdBy;\r\n    }\r\n\r\n    // Getter methods:\r\n    public String getId() {\r\n        return id;\r\n    }\r\n    public String getPayload() {\r\n        return payload;\r\n    }\r\n    public TaskType getType() {\r\n        return type;\r\n    }\r\n    public TaskStatus getStatus() {\r\n        return status;\r\n    }\r\n    public int getAttempts() {\r\n        return attempts;\r\n    }\r\n    public int getMaxRetries() {\r\n        return maxRetries;\r\n    }\r\n    public String getCreatedAt() {\r\n        return createdAt.toString();\r\n    }\r\n    public String getCreatedBy() { return createdBy; }\r\n\r\n    // Setter methods:\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n    public void setPayload(String payload) {\r\n        this.payload = payload;\r\n    }\r\n    public void setType(TaskType type) {\r\n        this.type = type;\r\n    }\r\n    public void setStatus(TaskStatus status) {\r\n        this.status = status;\r\n    }\r\n    public void setAttempts(int attempts) {\r\n        this.attempts = attempts;\r\n    }\r\n    public void setMaxRetries(int maxRetries) {\r\n        this.maxRetries = maxRetries;\r\n    }\r\n    public void setCreatedAt(Instant createdAt) {\r\n        this.createdAt = createdAt;\r\n    }\r\n    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }\r\n\r\n    // REFACTORING-TO-DO: I have not factored \"createdBy\" field into the stuff below (should I? Figure out later).\r\n    // toString():\r\n    @Override\r\n    public String toString() {\r\n        return \"Task: [id: \" + id + \", payload: \" + payload + \", type: \" + type + \", status: \" + status + \", attempts: \" + attempts + \", maxRetries: \" + maxRetries + \", createdAt: \" + createdAt + \"]\";\r\n    }\r\n    // hashCode():\r\n    @Override\r\n    public int hashCode() {\r\n        // return Objects.hash(id, payload, type, status, attempts, maxRetries, createdAt);\r\n        int hash = 7;\r\n        hash = 31 * hash + (id == null ? 0: id.hashCode()); // NOTE: Not a numerical id! (stored in String for ar reason).\r\n        hash = 31 * hash + (payload == null ? 0: payload.hashCode());\r\n        hash = 31 * hash + (type == null ? 0: type.hashCode());\r\n        hash = 31 * hash + (status == null ? 0: status.hashCode());\r\n        hash = 31 * hash + attempts;\r\n        hash = 31 * hash + maxRetries;\r\n        hash = 31 * hash + (createdAt == null ? 0: createdAt.hashCode());\r\n        return hash;\r\n    }\r\n    // equals():\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if(this == o) return true;\r\n        if(o == null || getClass() != o.getClass()) return false;\r\n        Task task = (Task) o;\r\n        return Objects.equals(id, task.id) && Objects.equals(payload, task.payload) && Objects.equals(type, task.type) && status == task.status && attempts == task.attempts && maxRetries == task.maxRetries && Objects.equals(createdAt, task.createdAt);\r\n    }\r\n}\r\n",
      "info": {
        "size": 6214,
        "last_modified": "2025-12-12T15:03:50.4696339",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\models\\TaskHandlerRegistry.java",
      "content": "package com.springqprobackend.springqpro.models;\r\n\r\nimport com.springqprobackend.springqpro.handlers.TaskHandler;\r\nimport org.springframework.stereotype.Component;\r\nimport java.util.Map;\r\n\r\n/* NOTE: Instead of just having a \"private final Map<String, TaskHandler> handlers;\" field inside my Worker.java class,\r\nI'm going to have this TaskHandlerRegister component that'll automatically collect all the TaskHandler beans and\r\nprovide easy lookup methods (that I'll obviously define in this class).\r\n\r\nThis is better than having, like, a Map<String,TaskHandler> handlers field in my Worker.java class. (Which is what\r\nI originally had, but it ended up being pretty problematic when attempting to instantiate new Task types elsewhere.\r\nLike I couldn't do new Worker(task, this, new Map<String,TaskHandler>()); because that handlers map is meant to be\r\na Spring-managed collection of beans, not something to instantiate).\r\n(And so TaskHandlerRegistry is basically an intermediary/abstraction for that aspect).\r\n*/\r\n\r\n@Component\r\npublic class TaskHandlerRegistry {\r\n    /* This new field added below relates to my move away from the switch-case handling of jobs/tasks based on type\r\n    and towards handling them using external classes that implement an interface that'll be managed by this map below: */\r\n\r\n    private final Map<String,TaskHandler> handlers;\r\n    // Spring will automatically inject all beans that implement TaskHandler using @Component(\"TYPE\") as the key.\r\n    public TaskHandlerRegistry(Map<String, TaskHandler> handlers) {\r\n        this.handlers = handlers;\r\n    }\r\n    public TaskHandler getHandler(String type) {\r\n        //return handlers.get(type);\r\n        return handlers.getOrDefault(type, handlers.get(\"DEFAULT\"));    // <-- DEBUG: TO HANDLE MISC / UNRECOGNIZED JOB/TASK TYPES.\r\n    }\r\n    public Map<String, TaskHandler> getAllHandlers() {\r\n        return handlers;\r\n    }\r\n}\r\n",
      "info": {
        "size": 1902,
        "last_modified": "2025-12-12T15:03:50.4855232",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\redis\\RedisDistributedLock.java",
      "content": "package com.springqprobackend.springqpro.redis;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport java.time.Duration;\r\nimport java.util.Collections;\r\nimport java.util.UUID;\r\n\r\n/* RedisDistributedLock.java\r\n--------------------------------------------------------------------------------------------------\r\nThis file implements a lightweight Redis-based distributed lock using the Redis command:\r\n\"SET key value NX PX ttl\". So, this is used in ProcessingService.java, particularly its claimAndProcess()\r\nmethod that deals with enqueued Tasks. That file originally relied on, still present, Atomic state transition\r\nmethods as a way to \"lock\" down threads using ProcessService to process Tasks and prevent double-processing.\r\nWith the integration of Redis, this more secure Redis Distributed Locks are like an extra layer of\r\nsecurity making sure that only one worker thread can process a task at a time.\r\n- Also has method with a Lua script inside that checks token.\r\n\r\nSupposedly, the in-memory locking would fail in multi-instance environments and so Redis optimistic locks\r\ncompensate for that shortcoming. (I don't know how to test this).\r\n\r\n[FUTURE WORK]: For CloudQueue, these features amy be added:\r\n- Redisson locks.\r\n- DynamoDB TTL-based locks.\r\n- SQS visibility timeouts.\r\n*/\r\n\r\n/* 2025-11-21-REDIS-PHASE-NOTE:\r\n- Safe lock using SET key value NX PX ms and a Lua script unlock that checks token (prevents deleting another holders lock).\r\n- How to use: String token = lock.tryLock(\"task:lock:\"+id, 10000); if(token!=null){ try { ... } finally { lock.unlock(...); } }\r\nSO BASICALLY, safe lock happens using SET NX PX, and we use a Lua script to unlock it. That's how this is going to work.\r\n*/\r\n@Component\r\npublic class RedisDistributedLock {\r\n    // Field(s):\r\n    //private final RedisTemplate<String, Object> redis;\r\n    private static final Logger logger = LoggerFactory.getLogger(RedisDistributedLock.class);\r\n    private final StringRedisTemplate redis;\r\n    private final DefaultRedisScript<Long> releaseScript;\r\n    // Constructor(s):\r\n    //public RedisDistributedLock(RedisTemplate<String, Object> redis) {\r\n    public RedisDistributedLock(StringRedisTemplate redis) {\r\n        this.redis = redis;\r\n        // [FOR UNLOCKING] -> Lua script: if redis.get(KEY)==ARGV[1] then del(KEY) return 1 else return 0 end.\r\n        String lua =\r\n                \"if redis.call('get', KEYS[1]) == ARGV[1] \" +\r\n                        \"then return redis.call('del', KEYS[1]) \" +\r\n                        \"else return 0 end\";\r\n        releaseScript = new DefaultRedisScript<>();\r\n        releaseScript.setScriptText(lua);\r\n        releaseScript.setResultType(Long.class);\r\n    }\r\n    // Methods:\r\n    public String tryLock(String key, long ttlMs) {\r\n        String token = UUID.randomUUID().toString();\r\n        Boolean ok = redis.opsForValue().setIfAbsent(key, token, Duration.ofMillis(ttlMs));\r\n        logger.info(\"[RedisLock] TRY key={} token={} success={}\", key, token, ok);\r\n        if(Boolean.TRUE.equals(ok)) return token;\r\n        return null;\r\n    }\r\n    public boolean unlock(String key, String token) {\r\n        Long res = redis.execute(releaseScript, Collections.singletonList(key), token);\r\n        logger.info(\"[RedisLock] UNLOCK key={} token={} -> {}\", key, token, res);\r\n        return res != null && res > 0;\r\n    }\r\n}\r\n",
      "info": {
        "size": 3608,
        "last_modified": "2025-12-12T15:03:50.5075434",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\redis\\RedisTokenStore.java",
      "content": "package com.springqprobackend.springqpro.redis;\r\n\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.stereotype.Component;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/* RedisTokenStore.java\r\n--------------------------------------------------------------------------------------------------\r\nThis file stores and checks refresh tokens in Redis to enable server-side token revocation, token\r\nrotation, and immediate logout with revocation of tokens. It's this file that ensures refresh\r\ntokens can be invalidated immediately. (Originally refresh tokens were not stored server-side\r\nbut now Redis provides stateful control of them).\r\n\r\n[FUTURE WORK]:\r\n- Could integrate expiration events for auto-cleanup or Redisson buckets.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@Component\r\npublic class RedisTokenStore {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(RedisTokenStore.class);\r\n    private final StringRedisTemplate redis;\r\n    // Constructor(s):\r\n    @Autowired\r\n    public RedisTokenStore(StringRedisTemplate redis) {\r\n        this.redis = redis;\r\n    }\r\n    // Method(s):\r\n    // Save refresh token for email:\r\n    public void storeRefreshToken(String refreshToken, String email, long ttlMs) {\r\n        logger.info(\"[RedisTokenStore] SET refreshToken (w/ email & ttl)\");\r\n        redis.opsForValue().set(\"refresh:\" + refreshToken, email, ttlMs, TimeUnit.MILLISECONDS);\r\n    }\r\n    // Get email from refresh token:\r\n    public String getEmailForToken(String refreshToken) {\r\n        logger.info(\"[RedisTokenStore] GET refreshToken\");\r\n        return redis.opsForValue().get(\"refresh:\" + refreshToken);\r\n    }\r\n    // Delete refresh token:\r\n    public void delete(String refreshToken) {\r\n        logger.info(\"[RedisTokenStore] DELETE refreshToken\");\r\n        redis.delete(\"refresh:\" + refreshToken);\r\n    }\r\n    public boolean hasActiveToken(String email) { return redis.hasKey(\"refresh:\" + email); }\r\n}\r\n",
      "info": {
        "size": 2174,
        "last_modified": "2025-12-12T15:03:50.5175508",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\redis\\Redis_Lua_Note.md",
      "content": "Redis supports server-side scripting using Lua (a lightweight, high-level, multi-paradigm programming language primarily designed\r\nfor embedded use within applications. It's known for its simplicity, efficiency, and ease of integration with other languages,\r\nparticularly C and C++), whcih allows for extending Redis' functionality and performing complex operations atomically.\r\n\r\n- Lua scripts execute as a single, atomic unit. This means that either the entire script completes successfully, or none of its\r\noperations are applied, ensuring data consistency even with multiple commands. This eliminates the need for explicit transactions\r\nor pipelines for atomicity within the script's execution.\r\n\r\n- Lua scripts can implement complex business logic, conditional execution, and custom data manipulations that aren't possible\r\nw/ individual Redis commands. They can access and modify Redis data structures and utilize most of the standard Redis commands\r\nthrough the redis.call() and redis.pcall() functions within the script.\r\n\r\n- Lua scripts are executed using the EVAL command, which takes the script itself, the number of keys the script will access,\r\nand then the keys and arguments as separate parameters. For subsequent executions of the same script, EVALSHA can be used with the \r\nscript's SHA1 digest for efficiency, avoiding repeated transmission of the full script.\r\n\r\n- Arguments passed to a Lua script are divided into KEYS and ARGV:\r\n- KEYS are used to specify the keys the script will interact with, allowing Redis to properly route commands in a clustered environment.\r\n- ARGV contains additional arguments or data needed by the script. Within the Lua script, these are accessible as tables KEYS[1], KEYS[2], etc.., and ARGV[1], ARGV[2], etc.\r\n- Important **NOTE**: Lua tables are 1-indexed (they start at index 1 instead of 0).\r\n\r\n- Error Handling: Lua scripts can manage errors within the script itself, allowing for more robust and self-contained logic.\r\n- Use Cases: Lua scripting is particularly useful for implementing atomic operations like distributed locks, counters with conditional increments, complex data migrations, or custom commands that combine multiple Redis operations.\r\n  (**Obviously in my case, I'm going to be using it for Distributed Locks**).\r\n",
      "info": {
        "size": 2287,
        "last_modified": "2025-12-12T15:03:50.5215617",
        "mime_type": "text/x-web-markdown",
        "extension": ".md"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\redis\\TaskRedisRepository.java",
      "content": "package com.springqprobackend.springqpro.redis;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.stereotype.Repository;\r\nimport java.time.Duration;\r\n\r\n/* TaskRedisRepository.java\r\n--------------------------------------------------------------------------------------------------\r\nThis file is my Redis repository. Of course, it's basically a Redis-based caching layer for TaskEntity\r\nobjects used to accelerate the retrieval of recently processed tasks and offloading read-heavy queries.\r\nIt's not really part of the core processing pipeline and more of an overall system performance enhancer.\r\n(Caching TaskEntity, the DataBase representation of our Tasks, rather than the domain in-memory Task is\r\nappropriate too fitting DDD: \"cache the authoritative persisted shape\").\r\n\r\n[FUTURE WORK]:\r\n- Redis Streams for Task Event logs in preparation for CloudQueue, probably.\r\n*/\r\n\r\n@Repository\r\npublic class TaskRedisRepository {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(TaskRedisRepository.class);\r\n    private static final String TASK_KEY_PREFIX = \"task:\";\r\n    private final RedisTemplate<String, Object> redis;\r\n    private final Duration ttl;\r\n    // Constructor(s):\r\n    public TaskRedisRepository(RedisTemplate<String, Object> redis, @Value(\"${cache.task.ttl-seconds:600}\") long ttlSeconds) {\r\n        this.redis = redis;\r\n        this.ttl = Duration.ofSeconds(ttlSeconds);\r\n    }\r\n    // Method(s):\r\n    private String key(String id) {\r\n        return TASK_KEY_PREFIX + id;\r\n    }\r\n\r\n    public void put(TaskEntity entity) {\r\n        if(entity == null || entity.getId() == null) return;\r\n        logger.info(\"[TaskRedisRepository](aka RedisCache) PUT {}\", entity.getId());\r\n        redis.opsForValue().set(key(entity.getId()), entity, ttl);\r\n    }\r\n\r\n    public TaskEntity get(String id) {\r\n        Object o = redis.opsForValue().get(key(id));\r\n        if(o == null || !(o instanceof TaskEntity)) return null;    // DEBUG: Maybe add logs too or something.\r\n        if(o instanceof TaskEntity) return (TaskEntity) o;\r\n        logger.info(\"[TaskRedisRepository](aka RedisCache) GET {}\", id);\r\n        return null;\r\n    }\r\n\r\n    public void delete(String id) {\r\n        logger.info(\"[TaskRedisRepository](aka RedisCache) DELETE {}\", id);\r\n        redis.delete(key(id));\r\n    }\r\n    // DEBUG:+NOTE:+TO-DO: I can add other methods like exists(), setIfAbsent() and so on...\r\n}\r\n",
      "info": {
        "size": 2643,
        "last_modified": "2025-12-12T15:03:50.5335806",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\repository\\TaskRepository.java",
      "content": "package com.springqprobackend.springqpro.repository;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Modifying;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Repository;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n/* TaskRepository.java\r\n--------------------------------------------------------------------------------------------------\r\nThis is the JPA (Java Persistence API) repository for TaskEntity.\r\n- Since it extends JpaRepository, it'll have all the basic CRUD operations for manipulating tasks,\r\nbut I've also got custom methods for Atomic state transition (extra locking defense in addition to\r\nRedis optimistic locking) and, in addition, querying by status.\r\n- This file is essentially the persistence backbone of the Task Orchestration System (very important).\r\n\r\n[HISTORY]:\r\nThis file was added once the system shifted away from a fully in-memory queue to persistence-based.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n/*\r\nNOTES-TO-SELF:\r\n- Spring Data JPA can automatically create repositories (DAOs - Data Access Objects) from interfaces.\r\n- By extending JpaRepository<TaskEntity, String>, you instantly get CRUD methods like:\r\n-- findAll()\r\n-- findById(String id)\r\n-- save(TaskEntity entity)\r\n-- deleteById(String id)\r\nYou can also define query methods using naming conventions.\r\n--------------------------------------------------------------------------------------------------------------\r\nNOTE(s)-TO-SELF - [PART TWO - 2025-11-13 EDITS]:\r\n- The @Modifying annotation in Spring Data JPA is for indicating a repository method (annotated with @Query)\r\nperforms a data modification (CRUD) operation.\r\n- The @Transactional annotation in Spring Boot is used to manage transactions declaratively. I use it\r\nin service/TaskService.java almost as a sort of \"rollback\" mechanism, but it also has ACID properties\r\n(Atomicity, Consistency, Isolation, and Durability) for database operations (which is important here).\r\n*/\r\n\r\n@Repository\r\npublic interface TaskRepository extends JpaRepository<TaskEntity, String> {\r\n    // NOTE: ^ In JpaRepository<TaskEntity, String>, the generic parameters mean entity type and primary key type.\r\n\r\n    /* Expanding on \"You can also define query methods using naming conventions.\"\r\n    Below is an example of that. W/ these, you never write SQL manually for simple queries.\r\n    -- Method names like findByStatus are descriptive enough to be parsed by Spring to generate queries.\r\n    -- Spring would read the line below as \"SELECT * FROM tasks WHERE status = ?\" (REMEMBER THIS!)\r\n    */\r\n    List<TaskEntity> findByStatus(TaskStatus status);\r\n    List<TaskEntity> findByType(TaskType type); // <-- 2025-11-19-DEBUG: I don't know why I'm only adding this now.\r\n\r\n    // 2025-11-25-NOTE: IMPLEMENTING JWT OWNERSHIP ADDITION:\r\n    @Query(\"\"\"\r\n            SELECT t\r\n            FROM TaskEntity t\r\n            WHERE (:status IS NULL OR t.status = :status)\r\n              AND (:type IS NULL OR t.type = :type)\r\n            \"\"\")\r\n    List<TaskEntity> findByStatusAndType(@Param(\"status\") TaskStatus status, @Param(\"type\") TaskType type);\r\n\r\n    /*\r\n    worker tries to claim e.g., via transitionStatus(id, QUEUED, INPROGRESS, currentAttempts+1).\r\n    If it returns 1, the claim succeeded; otherwise another worker claimed it or the status changed.\r\n    (This is meant to return the number of rows affected, so !=1 means the update didn't work for xyz reason.\r\n    Transition status only if the current status matches \"from\").\r\n    This is the atomic SQL-style step that prevents two workers from both starting work on the same task.\r\n    */\r\n    @Modifying\r\n    @Transactional\r\n    @Query(\"UPDATE TaskEntity t SET t.status = :to, t.attempts = :attempts WHERE t.id = :id AND t.status = :from\")\r\n    int transitionStatus(@Param(\"id\") String id, @Param(\"from\") TaskStatus from, @Param(\"to\") TaskStatus to, @Param(\"attempts\") int attempts);\r\n\r\n    // 2025-11-17-DEBUG: ADDING ANOTHER ONE TO SET A RE-ENQUEUED TASK'S STATUS BACK TO QUEUED!!!\r\n    @Modifying\r\n    @Transactional\r\n    @Query(\"UPDATE TaskEntity t SET t.status = :to WHERE t.id = :id AND t.status = :from\")\r\n    int transitionStatusSimple(@Param(\"id\") String id, @Param(\"from\") TaskStatus from, @Param(\"to\") TaskStatus to);\r\n\r\n    // 2025-11-25-DEBUG: NEW METHODS BELOW HELP ENFORCE JWT USER OWNERSHIP OF TASKS!!! (IN THE SERVICE/CONTROLLER LAYER).\r\n    List<TaskEntity> findAllByCreatedBy(String createdBy);\r\n    List<TaskEntity> findByStatusAndCreatedBy(TaskStatus status, String createdBy);\r\n    List<TaskEntity> findByTypeAndCreatedBy(TaskType type, String createdBy);\r\n    Optional<TaskEntity> findByIdAndCreatedBy(String id, String createdBy);\r\n}\r\n",
      "info": {
        "size": 5142,
        "last_modified": "2025-12-12T15:03:50.5549391",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\repository\\UserRepository.java",
      "content": "package com.springqprobackend.springqpro.repository;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.UserEntity;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\n\r\n/* UserRepository.java\r\n--------------------------------------------------------------------------------------------------\r\nThis is the JPA (Java Persistence API) repository for UserEntity.\r\n- Since it extends JpaRepository, it'll have all the basic CRUD for authentication and\r\nuser management.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\npublic interface UserRepository extends JpaRepository<UserEntity, String> { }\r\n",
      "info": {
        "size": 670,
        "last_modified": "2025-12-12T15:03:50.560958",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\runtime\\Worker.java",
      "content": "package com.springqprobackend.springqpro.runtime;\r\n\r\nimport com.springqprobackend.springqpro.models.TaskHandlerRegistry;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.handlers.TaskHandler;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\n/* Worker.java (DEPRECATED)\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nThis is the file that defined the Prototype Thread Worker that would be submitted by the ExecutorService\r\ninside QueueService.java. These Worker Threads were what initially processed enqueued Tasks (after popping\r\nthem off of QueueService), executing handlers directly. (In the initial stages of my project, QueueService\r\nwas the \"source of truth\", maintaining an in-memory Task map with the Worker-based pipeline via ExecutorService).\r\n- NOTE: See \"SpringQueue\" (Base) for the original Worker Thread in action (which built off of GoQueue).\r\n\r\nAfter the integration of ProcessingService.java, where database persistence was introduced, the Worker Thread\r\nwas demoted from being owners of business logic to just being \"runners of units of work\" that would pull\r\nthe latest persisted state from DataBase, \"be acknowledged\" and then ProcessingService would execute the\r\nappropriate handler and save the result back to the DataBase. (They no longer manipulated retries or\r\nre-enqueued failed tasks directly, basically just became vessels for invoking logic defined by ProcessingService).\r\n\r\nAs Redis was introduced (and further development of ProcessingService with optimistic locking, Redis locks, and so on),\r\neventually the purpose of the Worker Thread was phased out in conjunction with QueueService now having little more\r\npurpose than being a wrapper for an ExecutorService that would submit Task IDs (first saved to the DataBase and later pulled\r\nout and cached) for ProcessingService to process.\r\n\r\nNOTE: There still technically are \"worker threads\" but they aren't defined in this way anymore (they lack\r\nany real business logic and are just the default threads of QueueService's ExecutorService).\r\n--------------------------------------------------------------------------------------------------\r\nKept as historical artifact for reference.\r\n*/\r\n\r\n@Deprecated\r\npublic class Worker implements Runnable {\r\n    // Fields:\r\n    private static final Logger logger = LoggerFactory.getLogger(Worker.class);\r\n    private final Task task;\r\n    private final TaskHandlerRegistry handlerRegistry;\r\n\r\n    // Constructor:\r\n    public Worker(Task task, TaskHandlerRegistry handlerRegistry) {\r\n        this.task = task;\r\n        this.handlerRegistry = handlerRegistry;\r\n    }\r\n\r\n    // \"run\" will basically be this project's version of GoQueue's StartWorker():\r\n    @Override\r\n    public void run() {\r\n        String curThreadName = Thread.currentThread().getName();\r\n        try {\r\n            task.setAttempts(task.getAttempts() + 1);\r\n            task.setStatus(TaskStatus.INPROGRESS);\r\n            logger.info(\"[Worker {}] Processing task {} (Attempt {}, Type: {})\", curThreadName, task.getId(), task.getAttempts(), task.getType());\r\n\r\n            // Replacing the switch-case logic w/ this below:\r\n            TaskHandler handler = handlerRegistry.getHandler(task.getType().name());\r\n            handler.handle(task);\r\n        } catch(Exception e) {\r\n            logger.error(\"[Worker {}] Task {} failed due to error: {}\", curThreadName, task.getId(), e.getMessage());\r\n            task.setStatus(TaskStatus.FAILED);\r\n        }\r\n    }\r\n}\r\n",
      "info": {
        "size": 3635,
        "last_modified": "2025-12-12T15:03:50.5653393",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\CustomUserDetailsService.java",
      "content": "package com.springqprobackend.springqpro.security;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.UserEntity;\r\nimport com.springqprobackend.springqpro.repository.UserRepository;\r\nimport org.springframework.security.core.userdetails.User;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.stereotype.Service;\r\n\r\n/* CustomUserDetailsService.java\r\n--------------------------------------------------------------------------------------------------\r\nThis is the file that bridges UserEntity with Spring Security's UserDetails system to support\r\nauthentication, authorization filters, and JWT validation. Its role in the SpringQueuePro system\r\nis to basically look up users in the PostgreSQL storage and adapt them into Spring Security's model.\r\n- Before its addition, in the initial stages of the JWT phase, all login logic was in the controllers.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@Service\r\npublic class CustomUserDetailsService implements UserDetailsService {\r\n    private final UserRepository userRepo;\r\n    public CustomUserDetailsService(UserRepository userRepo) {\r\n        this.userRepo = userRepo;\r\n    }\r\n    @Override\r\n    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {\r\n        UserEntity user = userRepo.findById(email).orElseThrow(() -> new UsernameNotFoundException(email));\r\n\r\n        return User.builder()\r\n                .username(user.getEmail())\r\n                .password(user.getPasswordHash())   // BCrypt-hashed password\r\n                .roles(user.getRole())\r\n                .build();\r\n    }\r\n}\r\n",
      "info": {
        "size": 1840,
        "last_modified": "2025-12-12T15:03:50.5969034",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\dto\\AuthRequest.java",
      "content": "package com.springqprobackend.springqpro.security.dto;\r\n\r\npublic record AuthRequest(String username, String password) { }\r\n",
      "info": {
        "size": 123,
        "last_modified": "2025-12-12T15:03:50.5969034",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\dto\\AuthResponse.java",
      "content": "package com.springqprobackend.springqpro.security.dto;\r\n\r\npublic record AuthResponse(String accessToken, String refreshToken) { }\r\n",
      "info": {
        "size": 131,
        "last_modified": "2025-12-12T15:03:50.6127974",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\dto\\LoginRequest.java",
      "content": "package com.springqprobackend.springqpro.security.dto;\r\n\r\npublic record LoginRequest(String email, String password) { }\r\n",
      "info": {
        "size": 121,
        "last_modified": "2025-12-12T15:03:50.6198129",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\dto\\RefreshRequest.java",
      "content": "package com.springqprobackend.springqpro.security.dto;\r\n\r\npublic record RefreshRequest(String refreshToken) { }\r\n",
      "info": {
        "size": 113,
        "last_modified": "2025-12-12T15:03:50.6370836",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\dto\\RegisterRequest.java",
      "content": "package com.springqprobackend.springqpro.security.dto;\r\n\r\npublic record RegisterRequest(String email, String password) { }\r\n",
      "info": {
        "size": 124,
        "last_modified": "2025-12-12T15:03:50.6466087",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\JwtAuthenticationFilter.java",
      "content": "package com.springqprobackend.springqpro.security;\r\n\r\nimport com.springqprobackend.springqpro.service.TaskService;\r\nimport io.jsonwebtoken.ExpiredJwtException;\r\nimport io.jsonwebtoken.JwtException;\r\nimport jakarta.servlet.FilterChain;\r\nimport jakarta.servlet.ServletException;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\r\nimport org.springframework.stereotype.Component;\r\nimport org.springframework.web.filter.OncePerRequestFilter;\r\n\r\nimport java.io.IOException;\r\n\r\n/* JwtAuthenticationFilter.java\r\n--------------------------------------------------------------------------------------------------\r\nThis file extracts JWT access tokens from Authorization headers, validates them using JwtUtil,\r\nloads user details, and sets the Authentication into the SecurityContext. It's basically the\r\ncore security filter enabling stateless authentication for my GraphQL endpoints (and its REST\r\nparallel that I have too mostly for my own reference).\r\n\r\n[HISTORY]:\r\n- Originally started with token parsing alone. But grew with CustomUserDetailsService integration\r\nand now there's full expiration/validation and refresh token constraints.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@Component\r\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\r\n    private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);\r\n    private final JwtUtil jwtUtil;\r\n    private final UserDetailsService userDetailsService;\r\n    public JwtAuthenticationFilter(JwtUtil jwtUtil, UserDetailsService uds) {\r\n        this.jwtUtil = jwtUtil;\r\n        this.userDetailsService = uds;\r\n    }\r\n    @Override\r\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {\r\n        String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);\r\n        if(authHeader == null || !authHeader.startsWith(\"Bearer \")) {\r\n            // No JWT  let the request continue unauthenticated\r\n            chain.doFilter(request, response);\r\n            return;\r\n        }\r\n        String token = authHeader.substring(7);\r\n        try {\r\n            // 2025-11-27-NOTE: ADDITION BELOW TO FIX DESIGN FLAW W/ REFRESH TOKEN BEING APPROVED:\r\n            String type = jwtUtil.getTokenType(token);\r\n            if (!\"access\".equals(type)) {\r\n                // This includes: null, \"refresh\", malformed, missing type claim.\r\n                logger.info(\"[JwtAuthenticationFilter] Refresh Token rejected for API Authentication attempt.\");\r\n                SecurityContextHolder.clearContext();\r\n                chain.doFilter(request, response);\r\n                return;\r\n            }\r\n            // 2025-11-27-NOTE: ADDITION ABOVE TO FIX DESIGN FLAW W/ REFRESH TOKEN BEING APPROVED.\r\n            String email = jwtUtil.validateAndGetSubject(token);\r\n            if (email != null && SecurityContextHolder.getContext().getAuthentication() == null) {\r\n                UserDetails userDetails = userDetailsService.loadUserByUsername(email);\r\n                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(\r\n                                userDetails,\r\n                                null,\r\n                                userDetails.getAuthorities()\r\n                );\r\n                auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\r\n\r\n                logger.info(\"[JwtAuthenticationFilter] Authorities for {} => {}\", email, auth.getAuthorities());\r\n\r\n                SecurityContextHolder.getContext().setAuthentication(auth);\r\n            }\r\n        } catch (Exception ex) {\r\n            // Token invalid/expired -> do NOT authenticate, just continue.\r\n            // SecurityContext remains empty -> downstream sees request as anonymous.\r\n            SecurityContextHolder.clearContext();\r\n            if(ex instanceof ExpiredJwtException) {\r\n                logger.warn(\"JWT expired: {}\");\r\n            }\r\n            if(ex instanceof JwtException) {\r\n                logger.warn(\"Invalid JWT: {}\");\r\n            }\r\n        }\r\n        chain.doFilter(request, response);\r\n    }\r\n}\r\n",
      "info": {
        "size": 4848,
        "last_modified": "2025-12-12T15:03:50.664409",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\JwtUtil.java",
      "content": "package com.springqprobackend.springqpro.security;\r\n\r\nimport io.jsonwebtoken.*;\r\nimport io.jsonwebtoken.security.Keys;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport javax.crypto.SecretKey;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.security.Key;\r\nimport java.util.Date;\r\nimport java.util.UUID;\r\n\r\n/* JwtUtil.java\r\n--------------------------------------------------------------------------------------------------\r\nThis file generates, validates, and parses JWT Access/Refresh tokens. It supports:\r\n- HS256 Signing\r\n- Access Token Expiry Enforcement\r\n- Refresh Token Rotation Checks\r\nIt's basically the cryptographic backbone of the SpringQueueProSystem.\r\nOriginally, the only method in here was a generateToken(email) method, but it's since evolved\r\ninto a complete JWT lifecycle manager.\r\n\r\n[FUTURE WORK]:\r\n- CloudQueue (AWS Deployment Version) might switch to RSA/ECDSA asymmetric keys and JWKS endpoints.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@Component\r\npublic class JwtUtil {\r\n    // Field(s):\r\n    private SecretKey key;\r\n    //private final long accessTokenExpirationMs = 15 * 60 * 1000; // 15 min\r\n    private final long accessTokenExpirationMs = 1 * 24 * 60 * 60 * 1000; // 2025-11-27-DEBUG: Changing to 1 day for live testing purposes. (15 minutes is honestly too short, should be ~3 hours or something).\r\n    private final long refreshTokenExpirationMs = 7 * 24 * 60 * 60 * 1000; // 7 days\r\n\r\n    // Constructor(s):\r\n    public JwtUtil(@Value(\"${jwt.secret}\") String secret) {\r\n        this.key = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));\r\n    }\r\n\r\n    // Method(s):\r\n    // SHORT-LIVED TOKEN:\r\n    public String generateAccessToken(String email) {\r\n        return Jwts.builder()\r\n                .subject(email)\r\n                .claim(\"type\", \"access\")\r\n                .claim(\"jti\", UUID.randomUUID().toString())\r\n                .issuedAt(new Date())\r\n                .expiration(new Date(System.currentTimeMillis() + accessTokenExpirationMs))\r\n                .signWith(key)\r\n                .compact();\r\n    }\r\n    // REFRESH TOKEN = LONG-LIVED TOKEN:\r\n    public String generateRefreshToken(String email) {\r\n        return Jwts.builder()\r\n                .subject(email)\r\n                .claim(\"type\", \"refresh\")\r\n                .claim(\"jti\", UUID.randomUUID().toString())\r\n                .issuedAt(new Date())\r\n                .expiration(new Date(System.currentTimeMillis() + refreshTokenExpirationMs))\r\n                .signWith(key)\r\n                .compact();\r\n    }\r\n    public String extractEmail(String token) {\r\n        return Jwts.parser()\r\n                .verifyWith(key)\r\n                .build()\r\n                .parseSignedClaims(token)\r\n                .getPayload()\r\n                .getSubject();\r\n    }\r\n    public boolean isExpired(String token) {\r\n        try {\r\n            Date expDate = Jwts.parser()\r\n                    .verifyWith(key)\r\n                    .build()\r\n                    .parseSignedClaims(token)\r\n                    .getPayload()\r\n                    .getExpiration();\r\n            return expDate.before(new Date());\r\n        } catch (Exception e) {\r\n            return true;    // Invalid tokens are expired.\r\n        }\r\n    }\r\n    // 2025-11-27-NOTE: New method being added to fix a design flaw w/ Refresh Token being approved for API Authentication (that's Access Token's job).\r\n    public String getTokenType(String token) {\r\n        try {\r\n            Claims claims = Jwts.parser()\r\n                    .verifyWith(key)\r\n                    .build()\r\n                    .parseSignedClaims(token)\r\n                    .getPayload();\r\n            return claims.get(\"type\", String.class);\r\n        } catch (Exception e) {\r\n            return null; // invalid / malformed token => treat as unusable\r\n        }\r\n    }\r\n\r\n    /* NOTE: This method below can definitely just combine isExpired and extractEmail but better to make it be a \"single parse\"\r\n    so I completely eliminate the possibility of signature tampering, corrupt tokens, and so on. */\r\n    /* Stuff that could go wrong apparently according to ChatGPT (if I just did isExpired -> extractEmail):\r\n    Invalid signature, Tampered or truncated token, Wrong key, Wrong algorithm, Null token, Missing subject\r\n    Expired token, and Other malformed JWT errors */\r\n    public String validateAndGetSubject(String token) {\r\n        try {\r\n            Claims claims = Jwts.parser()\r\n                    .verifyWith(key)\r\n                    .build()\r\n                    .parseSignedClaims(token)\r\n                    .getPayload();\r\n            // Check expiration manually (JJWT 0.12 no longer auto-fails expired tokens)\r\n            if (claims.getExpiration() == null || claims.getExpiration().before(new Date())) {\r\n                throw new ExpiredJwtException(null, claims, \"Token is expired\");\r\n            }\r\n            return claims.getSubject();\r\n        } catch (ExpiredJwtException ex) {\r\n            throw ex; // bubble up \"expired\" explicitly\r\n        } catch (JwtException ex) {\r\n            // SignatureException, MalformedJwtException, UnsupportedJwtException, etc.\r\n            throw new JwtException(\"Invalid JWT token\", ex);\r\n        } catch (IllegalArgumentException ex) {\r\n            throw new JwtException(\"JWT token is empty or null\", ex);\r\n        }\r\n    }\r\n\r\n}\r\n",
      "info": {
        "size": 5489,
        "last_modified": "2025-12-12T15:03:50.6684199",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\security\\RefreshTokenService.java",
      "content": "package com.springqprobackend.springqpro.security;\r\n\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/* RefreshTokenService.java\r\n--------------------------------------------------------------------------------------------------\r\nThis file orchestrates Refresh Token rotation, storage, and validation. It also delegates\r\npersistence to RedisTokenStore.java. This file ensures secure, OAuth2-style refresh\r\nbehavior with single-use refresh tokens, rotation on every login/refresh, and revocation\r\nvia user logout. (This feature was added as part of the JWT RBAC phase).\r\n\r\n[FUTURE WORK]:\r\n- Could integrate session metadata, device tracking, or audit logging. Who knows.\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n@Service\r\npublic class RefreshTokenService {\r\n    // Field(s):\r\n    private final StringRedisTemplate redis;\r\n    private final long ttlMs = 8L * 24 * 60 * 60 * 1000;    // refresh tokens last 8 days.\r\n    // Constructor(s):\r\n    public RefreshTokenService(StringRedisTemplate redis) {\r\n        this.redis = redis;\r\n    }\r\n    // Method(s):\r\n    private String key(String username) {\r\n        return \"refresh:\" + username;\r\n    }\r\n    public void storeToken(String username, String refreshToken) {\r\n        redis.opsForValue().set(\r\n                key(username),\r\n                refreshToken,\r\n                ttlMs,\r\n                TimeUnit.MILLISECONDS\r\n        );\r\n    }\r\n    public String getStoredToken(String username) {\r\n        return redis.opsForValue().get(key(username));\r\n    }\r\n    public void deleteToken(String username) {\r\n        redis.delete(key(username));\r\n    }\r\n}\r\n",
      "info": {
        "size": 1776,
        "last_modified": "2025-12-12T15:03:50.6821275",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\service\\ProcessingService.java",
      "content": "package com.springqprobackend.springqpro.service;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.domain.event.TaskCreatedEvent;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.handlers.TaskHandler;\r\nimport com.springqprobackend.springqpro.mapper.TaskMapper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.models.TaskHandlerRegistry;\r\nimport com.springqprobackend.springqpro.redis.RedisDistributedLock;\r\nimport com.springqprobackend.springqpro.redis.TaskRedisRepository;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport jakarta.persistence.EntityManager;\r\nimport jakarta.persistence.PersistenceContext;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.context.annotation.Lazy;\r\nimport org.springframework.context.ApplicationEventPublisher;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport io.micrometer.core.instrument.Counter;\r\nimport io.micrometer.core.instrument.Timer;\r\n\r\nimport java.time.Instant;\r\nimport java.util.*;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.ThreadPoolExecutor;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/* ProcessingService.java\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nThis class represents the architectural turning point of SpringQueuePro.\r\n\r\nOriginally, Task processing was done entirely inside QueueService using in-memory Worker threads.\r\nHandlers were responsible for mutating Task state and even manually scheduling retries. None of\r\nthis behavior was persisted, distributed, or concurrency-safe beyond a single instance.\r\n\r\nAs the system evolved (PostgreSQL persistence -> Redis locks -> retry policy unification), the\r\nprocessing logic needed to be centralized, durable, and consistent. ProcessingService was created\r\nto replace Worker threads entirely and become the single source of truth for task execution.\r\n\r\n[CURRENT ROLE]:\r\nThis class now performs the entire persisted lifecycle of a Task:\r\n - Atomically claim a TaskEntity via DB transition (QUEUED  INPROGRESS)\r\n - Convert TaskEntity  Task (domain object) using TaskMapper\r\n - Invoke the appropriate TaskHandler\r\n - Persist COMPLETED or FAILED back to PostgreSQL\r\n - Schedule retries using exponential backoff\r\n - Emit metrics for observability\r\n - Enforce Redis-backed distributed lock safety\r\n\r\n[NOTES]:\r\nAll retry logic, failure handling, status transitions, and attempts incrementing happen here now.\r\nHandlers simply express success or failure via normal return or thrown exception.\r\n\r\n[FUTURE WORK]:\r\nProcessingService is the part of SpringQueuePro that most cleanly maps onto CloudQueue. In the\r\nfuture, it may be replaced by:\r\n - External worker microservices\r\n - AWS SQS + Lambda consumers\r\n - ECS tasks running distributed handler workloads\r\n--------------------------------------------------------------------------------------------------\r\n*/\r\n\r\n// 2025-11-30-NOTE: The comment below should be preserved for later documentation:\r\n/* NOTE-TO-SELF: - [2025-11-13 EDIT]:\r\nThis is a new @Service file that will contain the transactional, DB-focused logic for\r\nclaiming and persisting a task's lifecycle. It'll be called from a QueueService worker thread\r\n(but the DB updates happen inside @Transactional methods here).\r\nBasically, this file is the transactional boundary for claiming and persisting TaskEntity changes.\r\n\r\nIn the overhaul I'm doing to harden the persistence flow, some of the logic originally contained in\r\nQueueService more or less gets migrated over here.\r\nEDIT: Actually, a lot of QueueService is getting moved over here.\r\n******************************************************************\r\n2025-11-14-DEBUG:+NOTE(S)-TO-SELF:\r\n*See notes appended to QueueService.java on which these notes build upon*\r\nProcessingService is the bridge between the Domain Layer (my in-memory Queue / QueueService + my Handlers) and the Persistence Layer (Postgres via Spring Data JPA).\r\nThis lets me treat the Queue as ephemeral and the DB as authoritative -- which is key in professional distributed/restartable systems.\r\n- ProcessingService is what now ensures that state transitions (PENDING  PROCESSING  COMPLETED/FAILED) are persisted atomically and safely.\r\nReally, ProcessingService.java, it's almost like a tool that's used by QueueService.java (so makes sense a lot of the\r\nfunctionality originally there is now ported over here -- great for decoupling but also moving towards my intended Event-Driven setup).\r\n\r\nProcessingService decoupling:\r\n- Task Claiming/Selection will no longer be in QueueService -> this has been moved to ProcessingService.claimAndProcess()\r\n- Task Processing was originally done by the Worker Threads in QueueService -> now they will be done in ProcessingService.\r\n- Task Status Updates were originally quite scattered (done in QueueService and individual Handlers) -> now centralized in ProcessingService w/ taskRepository.save()\r\n- Retry Scheduling, which was originally in QueueService as its own method -> now done in ProcessingService w/ Scheduler + Backoff Time\r\n\r\nThe try-catch block inside of method claimAndProcess() replaces the original low-level retry logic that was previously being\r\ndone in my Handlers (e.g., FailHandler).\r\n- Task Status updating is now centralized by way of repository instead of Handler.\r\n- The Scheduler in ProcessingService now does the retry scheduling originally done by QueueService.\r\n- Instead of fixed variable sleep times for retry (failed tasks), I have computeBackOffMs at the bottom. More on a comment appended there.\r\n\r\nNotes on ProcessingService.java:\r\n- claimAndProcess does the transitionStatus claim (atomic).\r\n- When claim succeeds, it reloads the entity and processes by invoking the handler through TaskHandlerRegistry.\r\n- Saves final state to DB and schedules retry if applicable.\r\n- ProcessingService guarantees that DB writes are serialized and safe via optimistic locking (@Version).\r\n- ProcessingService can use optimistic locking (@Version) to ensure only one worker processes a given task.\r\n\r\nAgain, what ProcessingService does now:\r\n- Direct DB saves (taskRepository.save)\r\n- Retry scheduling and backoff\r\n- Task claiming\r\n- Persistence of lifecycle changes (status, attempt count)\r\n\r\nEVERYTHING THAT WAS SO TIGHTLY COUPLED IN QueueService IS NOW DELEGATED HERE!\r\nNOW:\r\nQueueService = how to execute work.\r\nProcessingService = how to handle outcomes and persist them.\r\nAND:\r\nQueueService = a delivery system for work units  a producer/consumer dispatcher.\r\nProcessingService = owns state transitions and retry semantics.\r\nWorker threads now simply execute processing calls safely and concurrently, reading from durable state.\r\nThis is a textbook event-driven architecture with persistence-backed coordination.\r\nTHAT'S WHAT YOU FIND IN PROFESSIONAL-GRADE ARCHITECTURE MODELS LIKE Spring Batch, Celery, Sidekiq, and so on.\r\n*/\r\n@Service\r\npublic class ProcessingService {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(ProcessingService.class);\r\n    private final TaskRepository taskRepository;\r\n    private final TaskHandlerRegistry handlerRegistry;\r\n    private final TaskMapper taskMapper;\r\n    private final ScheduledExecutorService scheduler;   // Handles micro-level retry scheduling  backoff logic for failed tasks only.\r\n    private final QueueService queueService; // to re-enqueue by id when scheduling retries\r\n    private final RedisDistributedLock redisLock;   // 2025-11-23-DEBUG: REDIS INTEGRATION PHASE!\r\n    private final TaskRedisRepository cache;    // 2025-11-23-DEBUG: Refactoring for TaskRedisRepository.java\r\n    private final Deque<String> eventLog = new ArrayDeque<>();\r\n\r\n    @Autowired\r\n    private ApplicationEventPublisher publisher;\r\n\r\n    // 2025-11-26-NOTE:+DEBUG: METRICS PHASE FIELD ADDITIONS:\r\n    private final Counter tasksSubmittedCounter;\r\n    private final Counter tasksClaimedCounter;\r\n    private final Counter tasksCompletedCounter;\r\n    private final Counter tasksFailedCounter;\r\n    private final Counter tasksRetriedCounter;\r\n    private final Timer processingTimer;\r\n\r\n    @PersistenceContext\r\n    private EntityManager em;   // 2025-11-17-DEBUG: Need this for flush() and refresh(), which is professionally commonplace when working with Spring to enforce ordering.\r\n\r\n    // Constructor(s):\r\n    @Lazy\r\n    public ProcessingService(TaskRepository taskRepository, TaskHandlerRegistry handlerRegistry, TaskMapper taskMapper, @Qualifier(\"schedExec\") ScheduledExecutorService scheduler, QueueService queueService, RedisDistributedLock redisLock, TaskRedisRepository cache,\r\n                             Counter tasksSubmittedCounter, Counter tasksClaimedCounter, Counter tasksCompletedCounter, Counter tasksFailedCounter, Counter tasksRetriedCounter, Timer processingTimer) {\r\n        this.taskRepository = taskRepository;\r\n        this.handlerRegistry = handlerRegistry;\r\n        this.taskMapper = taskMapper;\r\n        this.scheduler = scheduler;\r\n        this.queueService = queueService;\r\n        this.redisLock = redisLock;\r\n        this.cache = cache;\r\n        // 2025-11-17-DEBUG:+NOTE: METRICS PHASE ADDITIONS:\r\n        this.tasksSubmittedCounter = tasksSubmittedCounter;\r\n        this.tasksClaimedCounter = tasksClaimedCounter;\r\n        this.tasksCompletedCounter = tasksCompletedCounter;\r\n        this.tasksFailedCounter = tasksFailedCounter;\r\n        this.tasksRetriedCounter = tasksRetriedCounter;\r\n        this.processingTimer = processingTimer;\r\n    }\r\n\r\n    // 2025-11-23-DEBUG: OVERHAULING MY claimAndProcess METHOD LOGIC [BELOW]:\r\n    // Method for attempting to claim a Task and process it. This method coordinates DB-level claim and handler execution.\r\n    // The retry doesnt live inside the handler anymore  its a post-processing policy in ProcessingService. If it throws, the failure is caught in the ProcessingService try/catch block.\r\n    @Transactional  // <-- forgot this, it should 100% be here.\r\n    public void claimAndProcess(String taskId) {\r\n        logEvent(\"CLAIM_START \" + taskId);\r\n        /* 2025-11-24-DEBUG: ADDING STRONG VALIDATION TO THIS METHOD AS PART OF JWT INTEGRATION!!!\r\n        ProcessingService MUST NOT trust or execute invalid Ids!!! */\r\n        if (!taskRepository.existsById(taskId)) {\r\n            logger.warn(\"WARNING: Processing request ignored  task does not exist.\");\r\n            return;\r\n        }\r\n        logger.info(\"[ProcessingService] starting claimAndProcess for {}\", taskId);\r\n\r\n        tasksSubmittedCounter.increment();  // DEBUG: METRICS ADDITION.\r\n\r\n        // Load current in-DB Task snapshot (it'll be \"frozen\" as QUEUED until this method \"claims\" it):\r\n        // NOTE: As alluded to, this is basically replacing the \"Thread dequeues as processes a Task\" functionality of QueueService.\r\n        Optional<TaskEntity> snapshot = taskRepository.findById(taskId);    // NOTE: Remember this is a built-in function when you extend JPA.\r\n        if(snapshot.isEmpty()) return;\r\n        TaskEntity current = snapshot.get();\r\n        // Attempt to claim: change QUEUED -> INPROGRESS (atomically w/ TaskRepository), increment attempts:\r\n        logger.info(\"[ProcessingService] attempting transition for {} attempts {}\", taskId, current.getAttempts() + 1);\r\n        int updated = taskRepository.transitionStatus(taskId, TaskStatus.QUEUED, TaskStatus.INPROGRESS, current.getAttempts() + 1);\r\n        logger.info(\"[ProcessingService] transition returned count={}\", updated);\r\n        if (updated == 0) {\r\n            logger.warn(\"[ProcessingService] claim for {} failed (transition returned 0)  likely status mismatch\", taskId);\r\n            return; // Claim failed: already claimed or status has been changed.\r\n        }\r\n\r\n        tasksClaimedCounter.increment();    // DEBUG: METRICS ADDITION.\r\n        logEvent(\"CLAIM_SUCCESS \" + taskId + \" attempt=\" + (current.getAttempts()));\r\n\r\n        em.flush();\r\n        em.refresh(current);\r\n\r\n        // Re-fetch the fresh TaskEntity now that we claimed it\r\n        TaskEntity claimed = taskRepository.findById(taskId).orElse(null);\r\n        if (claimed == null) return;\r\n\r\n        // 2025-11-23-DEBUG: OVERHAULING MY claimAndProcess METHOD LOGIC [1 - BELOW]:\r\n        String lockKey = \"task:lock:\" + taskId;\r\n        String token = redisLock.tryLock(lockKey, 2000);    // 2025-11-23-DEBUG:+TO-DO: Going to use 2000 for the processing time (that's what's in application.yml I think).\r\n        logEvent(\"LOCK_ACQUIRED \" + taskId);\r\n        if(token == null) {\r\n            // NOTE: REDIS LOCK NOT WORKING MEANS, FOR SAFETY, I SHOULD SET STATUS OF TASK BACK TO QUEUED SO OTHER CONSUMERS CAN GET IT:\r\n            logEvent(\"LOCK_FAILED \" + taskId + \" returning task to QUEUED\");\r\n            taskRepository.transitionStatus(taskId, TaskStatus.INPROGRESS, TaskStatus.QUEUED, claimed.getAttempts());\r\n            return;\r\n        }\r\n        // 2025-11-23-DEBUG: OVERHAULING MY claimAndProcess METHOD LOGIC [1 - ABOVE].\r\n\r\n        // Convert to in-memory Task model for existing handlers (you can also change handlers to accept TaskEntity)\r\n        // NOTE: Considered proper DDD Principle to NOT have Persistence Objects mix with my Handlers!\r\n        Task model = taskMapper.toDomain(claimed);\r\n\r\n        // try-catch-block to do the processing:\r\n        try {\r\n            /* 2025-11-26-NOTE: [METRICS RELATED]:\r\n            Need to use recordCallable to wrap the stuff when exceptions are possible. standard \"callable\"\r\n            won't propogate the exception to the outer try-catch block (it'll swallow the damn thing!). */\r\n            processingTimer.recordCallable(() -> {\r\n                logEvent(\"PROCESSING \" + taskId + \" type=\" + model.getType());\r\n                TaskHandler handler = handlerRegistry.getHandler(model.getType().name());\r\n                if (handler == null) handler = handlerRegistry.getHandler(\"DEFAULT\");\r\n                handler.handle(model);\r\n                return null;    // something needs to be returned for recordCallable.\r\n            });\r\n            model.setStatus(TaskStatus.COMPLETED);\r\n            taskMapper.updateEntity(model, claimed);    // 2025-11-15-EDIT: ADDED THIS!\r\n            TaskEntity persisted = taskRepository.save(claimed);\r\n            cache.put(claimed); // 2025-11-23-DEBUG: REFACTORING FOR TaskRedisRepository.java\r\n            tasksCompletedCounter.increment();  // 2025-11-26-NOTE: METRICS ADDITION!\r\n            logEvent(\"COMPLETED \" + taskId);\r\n            logger.info(\"[ProcessingService] after save - id: {}, status: {}, attempts: {}, version: {}\", persisted.getId(), persisted.getStatus(), persisted.getAttempts(), persisted.getVersion());\r\n        } catch(Exception ex) {\r\n            // ProcessingService catches Task FAILs gracefully - marking it as FAILED, persisting it, and re-enqueuing it with backoff.\r\n            // 2025-11-17-DEBUG: Actually have no idea what I was doing here.\r\n            model.setStatus(TaskStatus.FAILED);\r\n            taskMapper.updateEntity(model, claimed);\r\n            taskRepository.save(claimed);\r\n            cache.put(claimed); // 2025-11-23-DEBUG: REFACTORING FOR TaskRedisRepository.java\r\n            tasksFailedCounter.increment(); // 2025-11-26-NOTE: METRICS ADDITION!\r\n            logEvent(\"FAILED \" + taskId + \" attempt=\" + claimed.getAttempts());\r\n\r\n            em.flush();\r\n            em.refresh(claimed);\r\n\r\n            if (claimed.getAttempts() < claimed.getMaxRetries()) {\r\n                long delayMs = computeBackoffMs(claimed.getAttempts());\r\n                /* 2025-11-17-DEBUG: OKAY, it looks like I spotted a massive architectural flaw inside my processAndClaim() logic.\r\n                When a Thread tries to claim a Task, it does this: int updated = taskRepository.transitionStatus(taskId, TaskStatus.QUEUED, TaskStatus.INPROGRESS, current.getAttempts() + 1);,\r\n                but that's the thing -- it expects the persisted Task to be of type QUEUED, but the problem, when I re-enqueue a Task, I never\r\n                set the Status back to QUEUED; it remains FAILED so this method simply cannot run properly. That's why my Integration Test re-enqueing keeps messing up. */\r\n                int requeued = taskRepository.transitionStatusSimple(taskId, TaskStatus.FAILED, TaskStatus.QUEUED);\r\n                logger.info(\"[ProcessingService] requeue DB update for {} returned {}\", taskId, requeued);\r\n                tasksRetriedCounter.increment();    // 2025-11-26-NOTE: METRICS ADDITION!\r\n                scheduler.schedule(() -> queueService.enqueueById(taskId), delayMs, TimeUnit.MILLISECONDS);\r\n                logEvent(\"RETRY_SCHEDULED \" + taskId + \" delayMs=\" + delayMs);\r\n            } else {\r\n                // permanent failure:\r\n                logger.error(\"Task failed permanently. DEBUG: Come and write a more detailed case here later I barely slept.\");\r\n                logEvent(\"FAILED_PERMANENTLY \" + taskId);\r\n            }\r\n        } finally {\r\n            redisLock.unlock(lockKey, token); // 2025-11-23-DEBUG: LAST ADDITION FOR TaskRedisRepository.java REFACTORING PHASE.\r\n            logEvent(\"LOCK_RELEASE \" + taskId);\r\n        }\r\n        logger.info(\"[ProcessingService] finishing claimAndProcess for {} -> status now {}\", taskId, claimed.getStatus());\r\n    }\r\n    // 2025-11-23-DEBUG: OVERHAULING MY claimAndProcess METHOD LOGIC [ABOVE].\r\n\r\n    // 2025-12-07-NOTE: Adding a manual \"retry\" method (this was in the QueueService-era model of the project, never added it to ProcessingService era):\r\n    @Transactional\r\n    public boolean manuallyRequeue(String taskId) {\r\n        logEvent(\"RETRY_SCHEDULED_MANUALLY \" + taskId);\r\n        Optional<TaskEntity> opt = taskRepository.findById(taskId);\r\n        if(opt.isEmpty()) {\r\n            logger.warn(\"[ManualRequeue] Task {} not found.\", taskId);\r\n            return false;\r\n        }\r\n        TaskEntity task = opt.get();\r\n        // Only FAILED tasks may be manually requeued\r\n        if (task.getStatus() != TaskStatus.FAILED) {\r\n            logger.warn(\"[ManualRequeue] Task {} is not FAILED, ignoring.\", taskId);\r\n            return false;\r\n        }\r\n        // Reset status to QUEUED (and attempts to 0) for the sake of auto-retry:\r\n        int updated = taskRepository.transitionStatus(taskId, TaskStatus.FAILED, TaskStatus.QUEUED, 0);\r\n        if(updated == 0) {\r\n            logger.warn(\"[ManualRequeue] DB Transition FAILED->QUEUED did not update any rows.\");\r\n            return false;\r\n        }\r\n        // Re-read the fresh entity and update the cache:\r\n        TaskEntity refreshed = taskRepository.findById(taskId).orElseThrow();\r\n        cache.put(refreshed);\r\n        // Publish event - the listener will call enqueueById after the AFTER COMMIT (this is deliberate, can't directly call enqueueById, it's a bad idea):\r\n        publisher.publishEvent(new TaskCreatedEvent(this, taskId));\r\n        logger.info(\"[ManualRequeue] Task {} successfully re-enqueued manually (AFTER_COMMIT will enqueue worker).\", taskId);\r\n        return true;\r\n    }\r\n\r\n    /* NOTE: In my original setup from the ProtoType phase (SpringQueue), I had fixed times set for the Task processing\r\n    time. For Tasks that FAIL, that's not the greatest idea (static and don't adapt to retries). It's more professional\r\n    to have something like the method below which uses \"dynamic backoff.\" Which is better because:\r\n    - It reduces load on the system (if many tasks fail simultaneously, you won't hammer the DB or external services repeatedly).\r\n    - It avoids synchronized retries -- if all tasks waited 5 seconds exactly, they'd retry in lockstep (bad given new architectural overall).\r\n    - MOST IMPORTANTLY: This mimics cloud-native retry policies (it's what AWS SQS, Kafka consumers, and Resilience4j would apply automatically).\r\n\r\n    EDIT: It's only for retries that the exponential stuff is applied, and makes sense.\r\n    TO-DO: Edit the method below so that computeBackOffMs() uses values from TaskHandlerProperties as a \"base delay\" to be used as a multiplier.\r\n    (Best of both worlds and it's a nice thing to carry over from my prototype phase).\r\n    */\r\n    private long computeBackoffMs(int attempts) {\r\n        // exponential backoff base 1000ms. apparently this is common practice in cloud stuff so might as well start it now.\r\n        return (long) (1000 * Math.pow(2, Math.max(0, attempts - 1)));\r\n    }\r\n\r\n    // 2025-12-07-NOTE:+DEBUG: Metrics-related utility methods mainly for quality-of-life frontend features:\r\n    public void logEvent(String msg) {\r\n        synchronized (eventLog) {\r\n            eventLog.addFirst(\"[\" + Instant.now() + \"] \" + msg);\r\n            if (eventLog.size() > 200) eventLog.removeLast();  // size-bound buffer\r\n        }\r\n    }\r\n    public List<String> getRecentLogEvents() {\r\n        synchronized (eventLog) {\r\n            return new ArrayList<>(eventLog);\r\n        }\r\n    }\r\n    public Map<String, Object> getWorkerStatus() {\r\n        ThreadPoolExecutor exec = queueService.getExecutor();\r\n        int active = exec.getActiveCount();\r\n        int pool = exec.getPoolSize();\r\n        int idle = pool - active;\r\n\r\n        // Optional: if QueueService tracks # tasks currently processing - I have no idea.\r\n        int inFlight = active;\r\n        return Map.of(\r\n                \"active\", active,\r\n                \"idle\", idle,\r\n                \"inFlight\", inFlight\r\n        );\r\n    }\r\n}\r\n",
      "info": {
        "size": 21909,
        "last_modified": "2025-12-12T15:03:50.7013349",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\service\\QueueService.java",
      "content": "package com.springqprobackend.springqpro.service;\r\n\r\nimport com.springqprobackend.springqpro.config.QueueProperties;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.models.TaskHandlerRegistry;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport com.springqprobackend.springqpro.runtime.Worker;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.security.access.prepost.PreAuthorize;\r\nimport org.springframework.stereotype.Service;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport jakarta.annotation.PreDestroy;\r\nimport io.micrometer.core.instrument.Counter;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.concurrent.*;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\r\n\r\n/* QueueService.java (still relevant, but the bulk of its functionality is deprecated).\r\n--------------------------------------------------------------------------------------------------\r\n[HISTORY]:\r\nThis file here is basically the root from which this entire project originated from.\r\nQueueService was once the heart of SpringQueuePro and basically performed all the system logic\r\nwithin this one class; it maintained an in-memory ConcurrentHashMap of Tasks and executed\r\nhandlers itself via Worker threads (see deprecated Worker.java).\r\n\r\nAs the architecture involved (persistence moved to PostgreSQL, ProcessingService now handled\r\nthe processing logic, distributed locking moved to Redis, and retry logic was moved outside\r\nthe Handler implementations), the bulk of QueueService's functionality became obsolete.\r\n\r\n[CURRENT ROLE]:\r\nNow, QueueService is basically an intermediary between TaskEntity's enqueueById(taskId)\r\nmethod and ProcessingService's claimAndProcess() method. The latter marks a DataBase-persisted\r\nTask for ProcessingService's processing by first submitting it to ExecutorService (where the latter\r\nis invoked). This makes sure that ProcessingService is the single source of processing truth.\r\n--------------------------------------------------------------------------------------------------\r\nI've kept the legacy methods, in-memory maps, and so on as a historical artifact; they are not\r\npart of the modern production path.\r\n*/\r\n\r\n// 2025-11-30-NOTE: The massive comment blocks below should 100% be preserved for the documentation. Don't remove them yet!\r\n/* 2025-11-14-DEBUG:+REMINDER: After I finish my ProcessingService-based architectural overhaul of my program,\r\ndon't forget to remove QueueProperties from this file and adjust the second constructor to get rid of it\r\n(and also adjust the UnitTests for QueueService because that's what the second constructor is for, and I'll need to tweak stuff).\r\n^ Or maybe I can keep the manual declaration of ScheduledExecutor in the test constructor since the downside of\r\nmanual declaration is primarily for injection performance reasons, and I'm wiring it into the main constructor anyways?\r\n- Also I don't think I ever shut down ScheduledExecutor...\r\n- Now that I'm wiring in ScheduledExecutorService and ExecutorService, do I still need the .shutdown() statements?\r\n*/\r\n/* 2025-11-14-DEBUG:+REMINDER -- REFACTORED CHANGES TO QueueService.java:\r\n- Method enqueue(Task task) is kept but refactored for ProcessingService.java now instead.\r\n- Method retry(Task task, long delay) is basically obsolete. The Retry logic now lives in ProcessingService.java.\r\n***********************************************************************************************************************\r\nQueueService.java NEW PURPOSE (ProcessingService.java OVERHAUL) -- definitely port this stuff to README.md later:\r\n--\r\nI'm at the phase of my project now where I'm drastically overhauling and evolving the architecture of my project.\r\nMy program is really at the point now where it's transitioning away from a prototype queue (which is what GoQueue/SpringQueue really is)\r\nmainly for testing asynchronous execution -> transforming it into an event-driven, persistence-aware processing pipeline.\r\n[What QueueService was]:\r\n- A Task Queue responsible for holding Tasks in-memory. (Tasks were held in memory).\r\n- A Worker Pool manager that spins up Worker Threads via ExecutorService to process said Tasks concurrently.\r\n- A Retry Scheduler that re-enqueues failed tasks after a delay (e.g., queue.retry(task, sleepTime).\r\nIt basically handled everything: persistence simulation, concurrency, retry, and orchestration.\r\nThat makes total sense for a PROTOTYPE (GoQueue/SpringQueue) where persistence wasn't in play yet (the Queue was the system's state).\r\nOf course, this setup tightly coupled persistence and processing logic, meaning the DB couldn't easily \"see\" what was happening and couldn't\r\nhelp enforce concurrency rules (see the comment I leave in TaskEntity.java or wherever where I touch on that).\r\n[What QueueService is NOW / what I'm building to]:\r\nNow I have,\r\n- TaskEntity (the Persisted Task Record)\r\n- TaskRepository (for Durability -- it's the system of Records)\r\n- ProcessingService (for transactional, version-safe updates)\r\n- the event flow (TaskCreatedEvent -> TaskCreatedListener -> ProcessingService)\r\nI've basically changed the complete responsibility delegation.\r\nMEANING\r\nNow, QueueService is the layer that BRIDGES AND COORDINATES.\r\nQueueService's new purpose is to be the in-memory bridge between the durable world (DataBase) and the\r\ntransient processing world (Worker Threads / Executors here).\r\nQueueService no longer decides business outcomes (retry, fail, etc.) - instead it dispatches and coordinates.\r\n-- ALSO:\r\nQueueService's original enqueue() method where I submit new Worker(task,...) with the in-memory task is somewhat obsolete now.\r\nI'm keeping it as legacy code for now, but now -- in accordance with how ProcessingService.java works -- I've added enqueueById()\r\nwhich basically replaces it: submits a Runnable that calls ProcessingService.claimAndProcess() w/ a persisted Task ID,\r\n\"claims\" the Task in DB, and processes it from there.\r\n*/\r\n@Service\r\npublic class QueueService {\r\n    // Fields:\r\n    private static final Logger logger = LoggerFactory.getLogger(QueueService.class);\r\n    private final ExecutorService executor;\r\n    private final ConcurrentHashMap<String,Task> jobs;  // NOTE: W/ the ProcessingService.java overhaul, this field is obsolete along with probably some others.\r\n    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\r\n    private final Lock readLock = rwLock.readLock();\r\n    private final Lock writeLock = rwLock.writeLock();\r\n    private final TaskHandlerRegistry handlerRegistry;\r\n    private final ScheduledExecutorService scheduler;   // NOTE: Handles high-level queue scheduling  e.g., when to enqueue, re-enqueue, or drain tasks.\r\n    private final QueueProperties props;\r\n\r\n    // DEBUG: 2025-11-13 EDIT: Additions below.\r\n    private final TaskRepository taskRepository;        // DEBUG: For optional direct DB READS.\r\n    private final ProcessingService processingService;  // DEBUG: Do processing via transactional service.\r\n    // DEBUG: 2025-11-26 EDIT: METRICS-RELATED ADDITIONS BELOW!\r\n    private final Counter queueEnqueueCounter;\r\n    private final Counter queueEnqueueByIdCounter;\r\n\r\n    // Constructor:\r\n    @Autowired  // DEBUG: See if this fixes the issue!\r\n    public QueueService(TaskHandlerRegistry handlerRegistry, TaskRepository taskRepository, ProcessingService processingService, @Qualifier(\"execService\") ExecutorService executor, @Qualifier(\"schedExec\") ScheduledExecutorService scheduler, QueueProperties props,\r\n                        Counter queueEnqueueCounter, Counter queueEnqueueByIdCounter) {\r\n        this.jobs = new ConcurrentHashMap<>();\r\n        this.taskRepository = taskRepository;\r\n        this.processingService = processingService;\r\n        this.executor = executor;\r\n        this.scheduler = scheduler;\r\n        this.handlerRegistry = handlerRegistry;\r\n        this.props = props;\r\n        // DEBUG: 2025-11-26 EDIT: METRICS-RELATED ADDITIONS BELOW:\r\n        this.queueEnqueueCounter = queueEnqueueCounter;\r\n        this.queueEnqueueByIdCounter = queueEnqueueByIdCounter;\r\n    }\r\n\r\n    // Constructor 2 (specifically for JUnit+Mockito testing purposes, maybe custom setups too I suppose):\r\n    public QueueService(ExecutorService executor, TaskHandlerRegistry handlerRegistry, TaskRepository taskRepository, ProcessingService processingService, QueueProperties props,\r\n                        Counter queueEnqueueCounter, Counter queueEnqueueByIdCounter){\r\n        this.jobs = new ConcurrentHashMap<>();\r\n        this.taskRepository = taskRepository;\r\n        this.processingService = processingService;\r\n        this.executor = executor;\r\n        this.scheduler = Executors.newScheduledThreadPool(props.getSchedExecWorkerCount());\r\n        this.handlerRegistry = handlerRegistry;\r\n        this.props = props;\r\n        // DEBUG: 2025-11-26 EDIT: METRICS-RELATED ADDITIONS BELOW:\r\n        this.queueEnqueueCounter = queueEnqueueCounter;\r\n        this.queueEnqueueByIdCounter = queueEnqueueByIdCounter;\r\n    }\r\n\r\n    // DEBUG: 2025-11-13 EDIT: Method additions below. (Kind of replaces some but I'm going to keep my old legacy methods too).\r\n    /* DEBUG: 2025-11-24 EDIT: Adding @PreAuthorize(...) below to ensure this method is never exposed to any GraphQL or REST APIs, must remain internal\r\n    (prevents hypothetical attackers from submitting arbitrary tasks to worker threads). This is just a good practice addition brother. */\r\n    //@PreAuthorize(\"denyAll()\")\r\n    public void enqueueById(String id) {\r\n        logger.info(\"[QueueService] enqueueById called for {}\", id);\r\n        queueEnqueueByIdCounter.increment();\r\n        executor.submit(() -> {\r\n                logger.info(\"[QueueService] submitting runnable for {}\", id);\r\n                processingService.claimAndProcess(id);\r\n        });\r\n    }\r\n\r\n    // 2025-12-07-NOTE: Some utility methods:\r\n    public ThreadPoolExecutor getExecutor() {\r\n        return (ThreadPoolExecutor) executor;\r\n    }\r\n\r\n    // OLD Methods:\r\n    // 1. Translating GoQueue's \"func (q * Queue) Enqueue(t task.Task) {...}\" function:\r\n    // EDIT: THE VERSION OF enqueue BELOW IS NOW LEGACY CODE FROM THE PROTOTYPE PHASE! enqueueById ABOVE WILL BE USED BY ProcessingService.java.\r\n    @Deprecated\r\n    public void enqueue(Task t) {\r\n        t.setStatus(TaskStatus.QUEUED);\r\n        queueEnqueueCounter.increment();\r\n        writeLock.lock();\r\n        try {\r\n            jobs.put(t.getId(), t); // GoQueue: q.jobs[t.ID] = &t;\r\n            executor.submit(new Worker(t, handlerRegistry));   // Submit an instance of a Worker to the ExecutorService (executor pool).\r\n        } finally {\r\n            writeLock.unlock();\r\n        }\r\n    }\r\n\r\n    // 2. Translating GoQueue's \"func (q * Queue) Clear() {...}\" function:\r\n    // (This is the method for \"emptying the queue\").\r\n    @Deprecated\r\n    public void clear() {\r\n        writeLock.lock();\r\n        try {\r\n            jobs.clear();\r\n        } finally {\r\n            writeLock.unlock();\r\n        }\r\n    }\r\n\r\n    // 3. Translating GoQueue's \"func (q * Queue) GetJobs() []*task.Task {...}\" function:\r\n    // This is the method for returning a copy of all the Jobs (Tasks) we have:\r\n    @Deprecated\r\n    public List<Task> getJobs() {\r\n        readLock.lock();\r\n        try {\r\n            return new ArrayList<>(jobs.values());\r\n        } finally {\r\n            readLock.unlock();\r\n        }\r\n    }\r\n\r\n    // 5. Translating GoQueue's \"func (q * Queue) GetJobByID(id String) (*task.Task, bool)\" function:\r\n    // This is the method for returning a specific Job (Task) by ID:\r\n    @Deprecated\r\n    public Task getJobById(String id) {\r\n        /* In my GoQueue version of this function, I returned a bool and the Task, but the reasons for that\r\n        were entirely superfluous and I can just return null like a normal human being if Task isn't found. */\r\n        readLock.lock();\r\n        Task t = null;\r\n        try {\r\n            if(jobs.containsKey(id)) {\r\n                t = jobs.get(id);\r\n            }\r\n        } finally {\r\n            readLock.unlock();\r\n        }\r\n        return t;\r\n    }\r\n\r\n    // 6. Translating GoQueue's \"func (q * Queue) DeleteJob(id string) bool\" function:\r\n    // This is the method for deleting a specific Job (Task) by ID:\r\n    @Deprecated\r\n    public boolean deleteJob(String id) {\r\n        writeLock.lock();\r\n        boolean res = false;\r\n        try {\r\n            if(jobs.containsKey(id)) {\r\n                jobs.remove(id);\r\n                res = true;\r\n            }\r\n        } finally {\r\n            writeLock.unlock();\r\n        }\r\n        return res;\r\n    }\r\n\r\n    // 7. retry (see comment block above field \"private final ScheduledExecutorService scheduler\"):\r\n    // TO-DO: DELETE THE METHOD BELOW WHEN ProcessingService.java-REHAUL IS COMPLETE AND TESTED!\r\n    /*EDIT: LEGACY METHOD THAT WILL NO LONGER BE USED -- RETRY LOGIC WILL NOW LIVE IN ProcessingService.java\r\n    (RETRY SCHEDULING IS PERSISTENCE-DRIVEN NOW, NOT MANUAL LIKE IT WAS WITH QueueService AND THE METHOD BELOW: */\r\n    @Deprecated\r\n    public void retry(Task t, long delayMs) {\r\n        if(t.getStatus() != TaskStatus.FAILED) {\r\n            logger.info(\"[QueueService] Retry request for Task {} (non-FAILED Task) rejected!\", t.getId());\r\n            return;\r\n        }\r\n        scheduler.schedule(() -> enqueue(t), delayMs, TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n    // HELPER-METHOD(S): Might be helpful for monitoring endpoints if necessary...\r\n    @Deprecated\r\n    public int getJobMapCount() {\r\n        return jobs.size();\r\n    }\r\n\r\n    /* NOTE-TO-SELF:\r\n    - The ExecutorService needs explicit shutdown (else Spring Boot might hang on exit).\r\n    - This ensures clean terminal (very important when the service is deployed on Railway or whatever).\r\n    */\r\n    // NOTE: It's just hit me - I don't think I shutdown the scheduled executor????\r\n    // 2025-11-30-NOTE: NOT DEPRECATED!!!\r\n    @PreDestroy\r\n    public void shutdown() {\r\n        logger.info(\"[Inside @PreDestroy method] Shutting down QueueService...\");\r\n        executor.shutdown();\r\n        scheduler.shutdown();\r\n        try {\r\n            if(!executor.awaitTermination(5, TimeUnit.SECONDS)) {\r\n                executor.shutdownNow();\r\n                scheduler.shutdownNow();\r\n            }\r\n        } catch(InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n            executor.shutdownNow();\r\n            scheduler.shutdownNow();\r\n        }\r\n    }\r\n}\r\n",
      "info": {
        "size": 14736,
        "last_modified": "2025-12-12T15:03:50.7091055",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\service\\TaskService.java",
      "content": "package com.springqprobackend.springqpro.service;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.domain.event.TaskCreatedEvent;\r\nimport com.springqprobackend.springqpro.redis.TaskRedisRepository;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.context.ApplicationEventPublisher;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport io.micrometer.core.instrument.Counter;\r\nimport java.time.Instant;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n/* NOTES-TO-SELF:\r\n- This a service layer for calling repositories (DataBase) or queues.\r\n- This layer is called by the controller.\r\n- This file combines persistence (DataBase) and in-memory processing (QueueService).\r\n^ In other words: This Service orchestrates persistence and queue interaction.\r\n-- @Transactional is an annotation for if anything fails inside the method, then DataBase changes will roll back.\r\nEDIT: Forgot to wire this whole part in my bad.\r\n- ApplicationEventPublisher is an interface in the Spring Framework that encapsulates event publication functionality,\r\nallowing for decoupling of application components through event-driven architecture. [Google AI Description].\r\n*/\r\n// 2025-11-23-DEBUG: CACHE SYNCS SHOULD ALWAYS OCCUR AFTER DATA SAVES/WRITES (DB IS THE SOURCE OF TRUTH, COMES FIRST).\r\n@Service\r\npublic class TaskService {\r\n    private static final Logger logger = LoggerFactory.getLogger(TaskService.class);\r\n    private final TaskRepository repository;\r\n    private final QueueService queueService;\r\n    private final TaskRedisRepository cache;    // 2025-11-23-DEBUG: Refactoring for TaskRedisRepository.java\r\n\r\n    @Autowired\r\n    private ApplicationEventPublisher publisher;\r\n    // 2025-11-26-NOTE:+DEBUG: METRICS PHASE FIELD ADDITIONS:\r\n    private final Counter apiTaskCreateCounter;\r\n\r\n    public TaskService(TaskRepository repository, QueueService queueService, TaskRedisRepository cache, Counter apiTaskCreateCounter) {\r\n        this.repository = repository;\r\n        this.queueService = queueService;\r\n        this.cache = cache; // 2025-11-23-DEBUG: Refactoring for TaskRedisRepository.java\r\n        this.apiTaskCreateCounter = apiTaskCreateCounter;\r\n    }\r\n\r\n    // 2025-11-25-NOTE: JWT USER OWNERSHIP REFACTORING METHOD BELOW (PROBABLY MAKES THE OTHER ONE OBSOLETE -- will be what GraphQL calls now):\r\n    // NOTE: This is the new \"entry point\" used by GraphQL and I guess the JWT-protected REST stuff (but mainly GraphQL of course).\r\n    @Transactional\r\n    public TaskEntity createTaskForUser(String payload, TaskType type, String ownerEmail) {\r\n        apiTaskCreateCounter.increment();   // 2025-11-26-NOTE: METRICS ADDITION!\r\n        TaskEntity entity = new TaskEntity(\r\n                \"Task-\" + System.nanoTime(),\r\n                payload,\r\n                type,\r\n                TaskStatus.QUEUED,\r\n                0,\r\n                3,\r\n                Instant.now(),\r\n                ownerEmail\r\n        );\r\n        logger.info(\"[TaskService][createTaskForUser] About to save TaskEntity inside of TaskRepository.\");\r\n        repository.save(entity);\r\n        logger.info(\"[TaskService][createTaskForUser] TaskEntity has been saved inside of TaskRepository.\");\r\n\r\n        logger.info(\"[TaskService][createTaskForUser] About to save TaskEntity inside of TaskRedisRepository (Cache).\");\r\n        cache.put(entity);\r\n        logger.info(\"[TaskService][createTaskForUser] TaskEntity has been saved inside of TaskRedisRepository (Cache).\");\r\n\r\n        logger.info(\"[TaskService][createTaskForUser] About to publish TaskCreatedEvent.\");\r\n        publisher.publishEvent(new TaskCreatedEvent(this, entity.getId()));\r\n        logger.info(\"[TaskService][createTaskForUser] TaskCreatedEvent has been published.\");\r\n        return entity;\r\n    }\r\n\r\n    // 2025-11-25-DEBUG: JWT USER OWNERSHIP-RELATED REFACTORING METHODS:\r\n    // NOTE: Old global ones will remain -- I should probably add ADMIN status to them or something.\r\n    public List<TaskEntity> getAllTasksForUser(TaskStatus status, String ownerEmail) {\r\n        if (status == null) return repository.findAllByCreatedBy(ownerEmail);\r\n        return repository.findByStatusAndCreatedBy(status, ownerEmail);\r\n    }\r\n    public List<TaskEntity> getAllTasksForUserByType(TaskType type, String ownerEmail) {\r\n        if (type == null) return repository.findAllByCreatedBy(ownerEmail);\r\n        return repository.findByTypeAndCreatedBy(type, ownerEmail);\r\n    }\r\n    public Optional<TaskEntity> getTaskForUser(String id, String ownerEmail) {\r\n        return repository.findByIdAndCreatedBy(id, ownerEmail);\r\n    }\r\n    // 2025-11-25-DEBUG: Method below is probably legacy code now.\r\n    @Transactional\r\n    public TaskEntity createTask(String payload, TaskType type) {\r\n        TaskEntity entity = new TaskEntity(\r\n                \"Task-\" + System.nanoTime(),\r\n                payload,\r\n                type,\r\n                TaskStatus.QUEUED,\r\n                0,\r\n                3,\r\n                Instant.now()\r\n        );\r\n        repository.save(entity);\r\n        cache.put(entity);  // 2025-11-23-DEBUG: Refactoring for TaskRedisRepository.java (SAVE ENTITY IN CACHE AFTER DATABASE SAVE).\r\n        logger.info(\"[TaskService] saved task {}, publishing event\", entity.getId());\r\n        publisher.publishEvent(new TaskCreatedEvent(this, entity.getId()));\r\n        logger.info(\"[TaskService] published TaskCreatedEvent for {}\", entity.getId());\r\n        return entity;\r\n    }\r\n    // 2025-11-25-DEBUG: Method above is 100% legacy code now...\r\n\r\n    public List<TaskEntity> getAllTasks(TaskStatus status) {\r\n        // 2025-11-23-DEBUG: List queries should return DB-focused.\r\n        if (status == null) return repository.findAll();\r\n        return repository.findByStatus(status);\r\n    }\r\n    /* 2025-11-19-NOTE: I don't know why I didn't add this before, but I should definitely have the option\r\n    to getAllTasks via TaskType type as well, so I'm going to overload the method above. */\r\n    public List<TaskEntity> getAllTasks(TaskType type) {\r\n        // 2025-11-23-DEBUG: List queries should return DB-focused.\r\n        if(type == null) return repository.findAll();\r\n        return repository.findByType(type);\r\n    }\r\n\r\n    public Optional<TaskEntity> getTask(String id) {\r\n        // 2025-11-23-DEBUG: Refactoring for TaskRedisRepository.java (and Redis in general). Better to retrieve Task via ID from Cache!\r\n        logger.info(\"[TaskService][getTask] About to look in TaskRedisRepository (Redis Cache) for Task by id:{}\", id);\r\n        TaskEntity cached = cache.get(id);\r\n        if(cached != null) {\r\n            logger.info(\"[TaskService][getTask] Task (id:{}) WAS found in TaskRedisRepository (Redis Cache)\", id);\r\n            return Optional.of(cached);\r\n        } else {\r\n            logger.info(\"[TaskService][getTask] Task (id:{}) was NOT found in TaskRedisRepository (Redis Cache). It will NOW be cached!\", id);\r\n        }\r\n        Optional<TaskEntity> fromDB = repository.findById(id);\r\n        fromDB.ifPresent(cache::put);   // 2025-11-23-DEBUG: IMPORTANT! If Task is not in the cache but in DB, after retrieving it, save it to the cache...\r\n        return fromDB;\r\n    }\r\n\r\n    @Transactional\r\n    public void updateStatus(String id, TaskStatus newStatus, int updAttempts) {\r\n        // 2025-11-23-DEBUG: Edit method updateStatus(...) to sync the cache:\r\n        repository.findById(id).ifPresent(task -> {\r\n            task.setStatus(newStatus);\r\n            task.setAttempts(updAttempts);\r\n            repository.save(task);\r\n            logger.info(\"[TaskService][updateStatus] Updates to Task (id:{}) synced to the TaskRepository.\", id);\r\n            cache.put(task);    // 2025-11-23-DEBUG: SYNC THE CACHE!\r\n            logger.info(\"[TaskService][updateStatus] Updates to Task (id:{}) cached to TaskRedisRepository (Redis Cache).\", id);\r\n        });\r\n    }\r\n\r\n    @Transactional\r\n    public boolean deleteTask(String id) {\r\n        // 2025-11-23-DEBUG: Edit method deleteTask(...) to sync the cache:\r\n        if (repository.existsById(id)) {\r\n            repository.deleteById(id);\r\n            logger.info(\"[TaskService][deleteTask] Task (id:{}) has been deleted from TaskRepository.\", id);\r\n            cache.delete(id);   // 2025-11-23-DEBUG: SYNC THE CACHE!\r\n            logger.info(\"[TaskService][deleteTask] Task (id:{}) has been deleted from TaskRedisRepository (Redis Cache).\", id);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
      "info": {
        "size": 8865,
        "last_modified": "2025-12-12T15:03:50.7191401",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\SpringQueueProApplication.java",
      "content": "package com.springqprobackend.springqpro;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringQueueProApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringQueueProApplication.class, args);\n\t}\n\n}\n",
      "info": {
        "size": 341,
        "last_modified": "2025-12-12T15:03:50.7228938",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\util\\RealSleeper.java",
      "content": "package com.springqprobackend.springqpro.util;\r\n\r\nimport org.springframework.stereotype.Component;\r\n\r\n/* NOTE: So, from what I understand, this file -- a concrete implementation of the Sleeper interface -- is\r\nneeded because Spring **needs** to inject something concrete at runtime to satisfy the Sleeper interface.\r\nI mainly added the Sleeper interface and this implementation here to use in my Handler Unit Tests, so I could\r\nadjust the sleep times to remove them entirely for Unit Testing (scalability and decoupling is obviously also just improved design).\r\n-- When Spring sees, say, EmailHandler depends on a Sleeper, it'll dependency inject RealSleeper into it!\r\n*/\r\n@Component\r\npublic class RealSleeper implements Sleeper {\r\n    @Override\r\n    public void sleep(long millis) throws InterruptedException {\r\n        Thread.sleep(millis);\r\n    }\r\n}\r\n",
      "info": {
        "size": 854,
        "last_modified": "2025-12-12T15:03:50.7447939",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\java\\com\\springqprobackend\\springqpro\\util\\Sleeper.java",
      "content": "package com.springqprobackend.springqpro.util;\r\n\r\n@FunctionalInterface\r\npublic interface Sleeper {\r\n    void sleep(long millis) throws InterruptedException;\r\n}\r\n",
      "info": {
        "size": 161,
        "last_modified": "2025-12-12T15:03:50.7545618",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "main\\resources\\application-prod.yml",
      "content": "spring:\r\n  datasource:\r\n    url: jdbc:postgresql://${PGHOST}:${PGPORT}/${PGDATABASE}\r\n    username: ${PGUSER}\r\n    password: ${PGPASSWORD}\r\n\r\n    hikari:\r\n      maximum-pool-size: 5\r\n      minimum-idle: 2\r\n      idle-timeout: 10000          # 10s  close idle connections fairly quickly\r\n      max-lifetime: 30000          # 30s  recycle before Railway drops them\r\n      connection-timeout: 10000    # 10s  don't hang forever\r\n      validation-timeout: 5000     # 5s  quick fail for bad connections\r\n      leak-detection-threshold: 20000  # 20s  log if a connection is stuck\r\n\r\n  jpa:\r\n    hibernate:\r\n      ddl-auto: update\r\n    show-sql: false\r\n    open-in-view: false\r\n    properties:\r\n      hibernate:\r\n        format_sql: false\r\n        jdbc:\r\n          lob:\r\n            non_contextual_creation: true\r\n\r\n  redis:\r\n    host: ${REDISHOST}\r\n    port: ${REDISPORT}\r\n    password: ${REDISPASSWORD}\r\n    ssl: false  # # internal Railway Redis uses plain TCP.\r\n\r\njwt:\r\n  secret: ${JWT_SECRET}\r\n  expiration-ms: 900000       # 15 min\r\n  refresh-expiration-ms: 604800000 # 7 days\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"health,metrics,prometheus\"\r\n",
      "info": {
        "size": 1200,
        "last_modified": "2025-12-12T15:03:50.7981769",
        "mime_type": "text/x-yaml",
        "extension": ".yml"
      }
    },
    {
      "path": "main\\resources\\application.properties",
      "content": "spring.application.name=springqpro\nqueue.main-exec-worker-count=5\nqueue.sched-exec-worker-count=1\nt-handler.default-sleep-time=2000\nt-handler.data-clean-up-sleep-time=3000\nt-handler.email-sleep-time=2000\nt-handler.fail-sleep-time=1000\nt-handler.fail-succ-sleep-time=2000\nt-handler.fail-abs-sleep-time=1000\nt-handler.news-letter-sleep-time=4000\nt-handler.report-sleep-time=5000\nt-handler.sms-sleep-time=1000\nt-handler.takes-long-sleep-time=10000\n",
      "info": {
        "size": 445,
        "last_modified": "2025-12-12T15:03:50.8022552",
        "mime_type": "text/x-java-properties",
        "extension": ".properties"
      }
    },
    {
      "path": "main\\resources\\application.yml",
      "content": "spring:\r\n  datasource:\r\n    url: jdbc:postgresql://localhost:5432/springqpro\r\n    username: springqpro\r\n    password: springqpro\r\n    driver-class-name: org.postgresql.Driver\r\n\r\n  jpa:\r\n    hibernate:\r\n      ddl-auto: update\r\n    show-sql: true\r\n    properties:\r\n      hibernate:\r\n        format_sql: true\r\n\r\n  redis:\r\n    host: ${REDIS_HOST:localhost}\r\n    port: ${REDIS_PORT:6379}\r\n    timeout: 2000ms\r\n    lettuce:\r\n      pool:\r\n        enabled: true\r\n        max-active: 8\r\n        max-idle: 8\r\n        min-idle: 0\r\n\r\n# Redis cache defaults for my Task entities.\r\ncache:\r\n  task:\r\n    ttl-seconds: 600  # 10 minutes\r\n\r\ngraphql:\r\n  graphiql:\r\n    enabled: true  # enable in-browser GraphiQL UI\r\n  schema:\r\n    locations: classpath:graphql/\r\n\r\njwt:\r\n  secret: \"84a10c506cede01a0fcf7cd8bf69f47d6180042e94abb035961cb642f6dc8b59690cfa49\"\r\n  expirationMs: 86400000   # 24 hours\r\n\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: health,info,metrics,prometheus\r\n  endpoint:\r\n    health:\r\n      show-details: always\r\n  metrics:\r\n    tags:\r\n      application: springqueuepro",
      "info": {
        "size": 1092,
        "last_modified": "2025-12-12T15:03:50.8182103",
        "mime_type": "text/x-yaml",
        "extension": ".yml"
      }
    },
    {
      "path": "main\\resources\\graphql\\schema.graphqls",
      "content": "# NOTE-TO-SELF: The GraphQL endpoint and controller I have is to query DataBase-persisted Tasks (not in-memory).\r\n# NOTE-TO-SELF: This is basically just replicating the structure of TaskService.java (also partly for interacting with the DB).\r\ntype Task {\r\n    id: ID!\r\n    payload: String!\r\n    type: TaskType!\r\n    status: TaskStatus!\r\n    attempts: Int!\r\n    maxRetries: Int!\r\n    createdAt: String!\r\n    createdBy: String!\r\n}\r\n\"\"\"\r\nEnumeration for Task Status:\r\n\"\"\"\r\n# Pasting what's in /enums/TaskStatus.java:\r\nenum TaskStatus {\r\n    QUEUED,\r\n    INPROGRESS,\r\n    COMPLETED,\r\n    FAILED\r\n}\r\n\"\"\"\r\nEnumeration for Task Type:\r\n\"\"\"\r\n# Pasting what's in /enums/TaskType.java:\r\nenum TaskType {\r\n    EMAIL,\r\n    REPORT,\r\n    DATACLEANUP,\r\n    SMS,\r\n    NEWSLETTER,\r\n    TAKESLONG,\r\n    FAIL,\r\n    FAILABS,\r\n    TEST\r\n}\r\n\"\"\"\r\nInput type for creating a new task.\r\n\"\"\"\r\ninput CreateTaskInput {\r\n    payload: String!\r\n    type: TaskType!\r\n}\r\n\"\"\"\r\nInput type for updating an existing task (partial / standard routine update as part of the system flow).\r\n\"\"\"\r\ninput StdUpdateTaskInput {\r\n    id: ID!,\r\n    status: TaskStatus,\r\n    attempts: Int\r\n}\r\n\"\"\"\r\n2025-12-05-NOTE: Adding this type mostly for the sake of the frontend (dynamically loading in the enums):\r\n\"\"\"\r\ntype TaskEnums {\r\n    taskTypes: [String!]!\r\n    taskStatuses: [String!]!\r\n}\r\n\"\"\"\r\nQueries for fetching tasks.\r\nAll queries automatically apply per-user filtering (by createdBy) at the controller/service layer.\r\n\"\"\"\r\n# Query = to retrieve/read data.\r\ntype Query {\r\n    \"\"\"\r\n    For retrieving tasks w/ option to pass TaskStatus to filter. Returned value must bare-minimum be an empty list (of non-NULL Tasks).\r\n    \"\"\"\r\n    tasks(status:TaskStatus): [Task!]!\r\n    \"\"\"\r\n    For retrieving tasks w/ option to pass TaskType to filter. Returned value must bare-minimum be an empty list (of non-NULL Tasks).\r\n    \"\"\"\r\n    tasksType(type:TaskType): [Task!]!\r\n    \"\"\"\r\n    Retrieving a single task given ID:\r\n    \"\"\"\r\n    task(id: ID!): Task\r\n    \"\"\"\r\n    2025-12-05-NOTE: NEW\r\n    \"\"\"\r\n    taskEnums: TaskEnums!\r\n}\r\n# Mutation = to update/write data.\r\ntype Mutation {\r\n    \"\"\"\r\n    Create and enqueue a new task:\r\n    \"\"\"\r\n    createTask(input: CreateTaskInput!): Task!\r\n    \"\"\"\r\n    Update Task attributes (namely, status and attempts #):\r\n    \"\"\"\r\n    # NOTE: In my in-memory QueueService, these updates occur programmatically, but this function will serve to translate changes to DB.\r\n    updateTask(input: StdUpdateTaskInput!): Task\r\n    \"\"\"\r\n    Deleting a Task by ID:\r\n    \"\"\"\r\n    deleteTask(id: ID!): Boolean!\r\n    \"\"\"\r\n    2025-12-05-NOTE: Adding this one for the frontend...\r\n    Retrying a Task by ID:\r\n    \"\"\"\r\n    retryTask(id: ID!): Boolean!\r\n}\r\n",
      "info": {
        "size": 2711,
        "last_modified": "2025-12-12T15:03:50.8182103",
        "mime_type": "text/plain",
        "extension": ".graphqls"
      }
    },
    {
      "path": "main\\resources\\static\\graphiql\\index.html",
      "content": "<!-- Just pasting the file from here: https://github.com/spring-projects/spring-graphql/blob/main/spring-graphql/src/main/resources/graphiql/index.html\r\nfound from: https://github.com/graphql/graphiql/issues/4033#issuecomment-3001804909\r\n\r\nSpring Boot 3.3+  and Spring for GraphQL 1.3+ no longer serve GraphiQL automatically at /graphiql because\r\nGraphiiQL 5.x+ has moved to an ESM-only build, breaking the old webjars-based static resource inclusion that Spring Boot used.\r\nAnd so, to have that GraphQL GUI in my project for testing, I need to create it from a static HTML file that loads GraphiQL from\r\na CDN (which I believe is what this file does -- I will be completely honest, I'm just borrowing it from the GitHub guy).\r\n\r\nNOTE: I have a thing where in order to reach the GraphiQL GUI, I need to specify /graphiql/index.html instead of just /graphiql/\r\nwhich I think is what is supposed to happen? Eitherway, I've added a re-direct controller to re-route /graphiql/ to /graphiql/index.html.\r\n-->\r\n\r\n<!doctype html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>GraphiQL</title>\r\n    <style>\r\n        body {\r\n            margin: 0;\r\n        }\r\n        #graphiql {\r\n            height: 100dvh;\r\n        }\r\n        .loading {\r\n            height: 100%;\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            font-size: 4rem;\r\n        }\r\n    </style>\r\n    <link rel=\"stylesheet\" href=\"https://esm.sh/graphiql@5.0.0/dist/style.css\"/>\r\n    <link rel=\"stylesheet\" href=\"https://esm.sh/@graphiql/plugin-explorer@5.0.0/dist/style.css\"/>\r\n    <script type=\"importmap\">\r\n        {\r\n          \"imports\": {\r\n            \"react\": \"https://esm.sh/react@19.1.0\",\r\n            \"react/jsx-runtime\": \"https://esm.sh/react@19.1.0/jsx-runtime\",\r\n            \"react-dom\": \"https://esm.sh/react-dom@19.1.0\",\r\n            \"react-dom/client\": \"https://esm.sh/react-dom@19.1.0/client\",\r\n            \"graphiql\": \"https://esm.sh/graphiql@5.0.0?standalone&external=react,react-dom,@graphiql/react,graphql\",\r\n            \"@graphiql/plugin-explorer\": \"https://esm.sh/@graphiql/plugin-explorer@5.0.0?standalone&external=react,@graphiql/react,graphql\",\r\n            \"@graphiql/react\": \"https://esm.sh/@graphiql/react@0.35.0?standalone&external=react,react-dom,graphql\",\r\n            \"@graphiql/toolkit\": \"https://esm.sh/@graphiql/toolkit@0.11.3?standalone&external=graphql\",\r\n            \"graphql\": \"https://esm.sh/graphql@16.11.0\"\r\n          }\r\n        }\r\n    </script>\r\n    <script type=\"module\">\r\n        import React from 'react';\r\n        import ReactDOM from 'react-dom/client';\r\n        import { GraphiQL, HISTORY_PLUGIN } from 'graphiql';\r\n        import { createGraphiQLFetcher } from '@graphiql/toolkit';\r\n        import { explorerPlugin } from '@graphiql/plugin-explorer';\r\n\r\n        import createJSONWorker from 'https://esm.sh/monaco-editor/esm/vs/language/json/json.worker.js?worker';\r\n        import createGraphQLWorker from 'https://esm.sh/monaco-graphql/esm/graphql.worker.js?worker';\r\n        import createEditorWorker from 'https://esm.sh/monaco-editor/esm/vs/editor/editor.worker.js?worker';\r\n\r\n        globalThis.MonacoEnvironment = {\r\n            getWorker(_workerId, label) {\r\n                switch (label) {\r\n                    case 'json':\r\n                        return createJSONWorker();\r\n                    case 'graphql':\r\n                        return createGraphQLWorker();\r\n                }\r\n                return createEditorWorker();\r\n            },\r\n        };\r\n\r\n        const params = new URLSearchParams(window.location.search);\r\n        const path = params.get(\"path\") || \"/graphql\";\r\n        const url = `${location.protocol}//${location.host}${path}`;\r\n        const wsPath = params.get(\"wsPath\") || \"/graphql\";\r\n        const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';\r\n        const subscriptionUrl = `${wsProtocol}//${location.host}${wsPath}`;\r\n        const gqlFetcher = createGraphiQLFetcher({'url': url, 'subscriptionUrl': subscriptionUrl});\r\n        const plugins = [HISTORY_PLUGIN, explorerPlugin()];\r\n        const xsrfToken = document.cookie.match(new RegExp('(?:^| )XSRF-TOKEN=([^;]+)'));\r\n        const initialHeaders = xsrfToken ? `{ \"X-XSRF-TOKEN\" : \"${ xsrfToken[1] }\" }` : `{}`;\r\n\r\n        function App() {\r\n            return React.createElement(GraphiQL, {\r\n                fetcher: gqlFetcher,\r\n                defaultEditorToolsVisibility: true,\r\n                headerEditorEnabled: true,\r\n                shouldPersistHeaders: true,\r\n                initialHeaders: initialHeaders,\r\n                plugins: plugins,\r\n            });\r\n        }\r\n\r\n        const container = document.getElementById('graphiql');\r\n        const root = ReactDOM.createRoot(container);\r\n        root.render(React.createElement(App));\r\n    </script>\r\n</head>\r\n<body>\r\n<div id=\"graphiql\"><div class=\"loading\">Loading...</div></div>\r\n</body>\r\n</html>",
      "info": {
        "size": 5048,
        "last_modified": "2025-12-12T15:03:50.8338869",
        "mime_type": "text/html",
        "extension": ".html"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\config\\RedisTestConfig.java",
      "content": "package com.springqprobackend.springqpro.config;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\r\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;\r\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.test.context.TestConfiguration;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.context.annotation.Primary;\r\nimport org.springframework.context.annotation.Profile;\r\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\r\nimport org.springframework.data.redis.connection.RedisStandaloneConfiguration;\r\nimport org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\r\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\r\n\r\n// 2025-11-23-NOTE: OVERRIDES REDISTEMPLATE AND STRINGREDISTEMPLATE SO TESTS CAN USE THE TESTCONTAINERS.\r\n// REDIS INSTANCE INJECTED WITH @SERVICECONNECTION\r\n@Profile(\"test\")\r\n@Configuration\r\npublic class RedisTestConfig {\r\n    @Bean\r\n    @Primary\r\n    public RedisTemplate<String, Object> redisTemplate(\r\n            RedisConnectionFactory factory\r\n    ) {\r\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\r\n        template.setConnectionFactory(factory);\r\n\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\r\n        mapper.registerModule(new JavaTimeModule());\r\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\r\n        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);\r\n\r\n        GenericJackson2JsonRedisSerializer jackson = new GenericJackson2JsonRedisSerializer(mapper);\r\n\r\n        template.setKeySerializer(new StringRedisSerializer());\r\n        template.setValueSerializer(jackson);\r\n        template.setHashKeySerializer(new StringRedisSerializer());\r\n        template.setHashValueSerializer(jackson);\r\n        template.afterPropertiesSet();\r\n\r\n        return template;\r\n    }\r\n\r\n    /* NEED TO OVERRIDE THE StringRedisTemplate WITH THE SAME CONNECTION FACTORY (THE CONTAINER FACTORY\r\n    INJECTED BY SPRING BOOT DUE TO @ServiceConnection)\r\n    - THIS WILL MAKE SURE StringRedisTemplate USES THE SAME Testcontainers FACTORY.\r\n    - MAKES SURE KEY LOOKUPS HIT THE SAME REDIS INSTANCE THE REPOSITORY WRITES TO!\r\n    */\r\n    @Bean\r\n    @Primary\r\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory factory) {\r\n        return new StringRedisTemplate(factory);\r\n    }\r\n}",
      "info": {
        "size": 3087,
        "last_modified": "2025-12-12T15:03:50.9151985",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\handlers\\DefaultHandlerTests.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\n// 2025-11-30-NOTE: Basically shouldn't be testing Handlers anymore. This is kept for my documentation stuff.\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Disabled;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.mockito.Mock;\r\nimport org.mockito.junit.jupiter.MockitoExtension;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\nimport static org.mockito.Mockito.mock;\r\nimport static org.mockito.Mockito.when;\r\n\r\n/* NOTE: I basically only have two types of Handlers defined as of this moment.\r\nThe variation you see in DefaultHandler mimicked across other Handlers w/ different sleep times.\r\n-- Picking DefaultHandler specifically since it's the *default* Handler I'll always have regardless of refactoring, etc.\r\n*/\r\n@ExtendWith(MockitoExtension.class)\r\npublic class DefaultHandlerTests {\r\n    private Sleeper fastSleeper;\r\n    private DefaultHandler handler;\r\n    private Task t;\r\n\r\n    @Mock\r\n    private TaskHandlerProperties props;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        /* NOTE: Very important is the line of code beneath this comment!\r\n        We're basically overriding the \"RealSleeper\" implementation of the Sleeper interface here\r\n        by using fastSleeper instead. Below is a lambda expression that implements Sleeper (functional interface),\r\n        which says that this Sleeper implementation takes some \"long\" var and just does nothing (doesn't actually sleep).\r\n        So we essentially skip the .sleep part of the Handler execution and skip straight to the followup logic. */\r\n        fastSleeper = millis -> {};\r\n        when(props.getDefaultSleepTime()).thenReturn(2000L);\r\n        handler = new DefaultHandler(fastSleeper, props);\r\n        t = new Task();\r\n        t.setId(\"Task-ArbitraryTaskId\");\r\n        t.setType(TaskType.valueOf(\"TEST\"));\r\n    }\r\n\r\n    /* 2025-11-20-EDIT: This file and DefaultHandlerTests.java is outdated, relying on the old project architecture\r\n    before any of the refactoring related to ProcessingService.java */\r\n    @Disabled\r\n    @Test\r\n    void handle_shouldSet_TaskCompleted() throws InterruptedException {\r\n        handler.handle(t);\r\n        assertEquals(TaskStatus.COMPLETED, t.getStatus());\r\n    }\r\n}\r\n",
      "info": {
        "size": 2619,
        "last_modified": "2025-12-12T15:03:50.9290038",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\handlers\\FailHandlerTests.java",
      "content": "package com.springqprobackend.springqpro.handlers;\r\n\r\n// 2025-11-30-NOTE: Basically shouldn't be testing Handlers anymore. This is kept for my documentation stuff.\r\n\r\n/* NOTE: Testing my FailHandler implementation of the TaskHandler class is a little bit tricky.\r\nThere are two things in my Handler classes that cause nondeterministic behavior (tests can't reliably assert outcomes).\r\nThe first is the Thread.sleep statement, which I've abstracted and taken care of w/ the \"RealSleeper\" model. Now, I need\r\nto take care of the new Random() variable I have in my FailHandler class.\r\n-- To do this, I've adjusted my FailHandler class to take a new argument in constructor initialization.\r\nNow, instead of declaring a new Random() variable in function, it's a class field instead and will be dependency injected\r\nby Spring. I'll have two constructors (both with the same arguments), but the one that's invoked depends on the number\r\nof arguments provided during object initialization. (And this is good too, because I don't have to interfere w/ Worker's\r\nlogic where I need to adjust how the handler is invoked).\r\n*/\r\n\r\nimport com.springqprobackend.springqpro.config.TaskHandlerProperties;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.util.Sleeper;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.service.QueueService;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Disabled;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.mockito.Mock;\r\nimport org.mockito.junit.jupiter.MockitoExtension;\r\n\r\nimport java.util.Random;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\nimport static org.mockito.Mockito.*;\r\n\r\n@ExtendWith(MockitoExtension.class)\r\npublic class FailHandlerTests {\r\n    @Mock\r\n    private QueueService queue;\r\n    @Mock\r\n    private TaskHandlerProperties props;\r\n\r\n    private Sleeper fastSleeper;\r\n    private Sleeper mockSleeper;\r\n    private FailHandler handler;\r\n    private Task t;\r\n    private Random fixedRandom;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        //when(props.getFailSleepTime()).thenReturn(1000L);\r\n        //when(props.getFailSuccSleepTime()).thenReturn(2000L);\r\n        fastSleeper = millis -> {}; // Define functional interface implementation w/ Lambda. (Remember this).\r\n        t = new Task();\r\n        t.setId(\"Task-ArbitraryTastkId\");\r\n        t.setAttempts(0);\r\n        t.setMaxRetries(3);\r\n        fixedRandom = mock(Random.class);\r\n        mockSleeper = mock(Sleeper.class);  // both mock sleepers will be used for different methods.\r\n    }\r\n\r\n    /* 2025-11-20-EDIT: This file and DefaultHandlerTests.java is outdated, relying on the old project architecture\r\n    before any of the refactoring related to ProcessingService.java */\r\n    @Disabled\r\n    @Test\r\n    void failHandler_completes_failedTask() throws InterruptedException {\r\n        /* In my FailHandler.java class, I define successOdds as 0.25, so if I guarantee fixedRandom.nextDouble returns 0.1\r\n        (which obv <= 0.25, so I'm in the % interval where my random odds succeeded), then I can let failHandler complete this task: */\r\n        when(props.getFailSuccSleepTime()).thenReturn(2000L);\r\n        when(fixedRandom.nextDouble()).thenReturn(0.1);\r\n        FailHandler failHandler = new FailHandler(queue, fastSleeper, fixedRandom, props);\r\n\r\n        failHandler.handle(t);\r\n        // Assertions:\r\n        assertEquals(TaskStatus.COMPLETED, t.getStatus());\r\n        verify(queue, never()).retry(any(Task.class), anyInt());\r\n    }\r\n\r\n    // This test case basically verifies that queue.retry(...) was called (when t.getAttempts() < t.getMaxRetries() and odds indicate no success).\r\n    @Disabled\r\n    @Test\r\n    void failHandler_retries_failedTask() throws InterruptedException {\r\n        when(props.getFailSleepTime()).thenReturn(1000L);\r\n        when(fixedRandom.nextDouble()).thenReturn(0.9);\r\n        // (Dunno if needed)DEBUG: when(queue.retry(any(Task.class),anyLong()).then???\r\n        FailHandler failHandler = new FailHandler(queue, fastSleeper, fixedRandom, props);\r\n        // Remember that t.setAttempts() == 0 and t.getMaxRetries() == 3 (there's still room for more attempts, so this case works fine).\r\n\r\n        failHandler.handle(t);\r\n        assertEquals(TaskStatus.FAILED, t.getStatus());\r\n        verify(queue, times(1)).retry(eq(t), eq(1000L));\r\n    }\r\n\r\n    // This test case confirms that queue.retry(...) is not ran when (t.getAttempts >= t.getMaxRetries() and odds indicate no success).\r\n    @Disabled\r\n    @Test\r\n    void failHandler_retires_maxFailedTask() throws InterruptedException {\r\n        when(props.getFailSleepTime()).thenReturn(1000L);\r\n        t.setAttempts(3);   // So, it goes straight to the failed if-condition branch.\r\n        when(fixedRandom.nextDouble()).thenReturn(0.9);\r\n        FailHandler failHandler = new FailHandler(queue, fastSleeper, fixedRandom, props);\r\n        failHandler.handle(t);\r\n        assertEquals(TaskStatus.FAILED, t.getStatus());\r\n        verify(queue, never()).retry(eq(t), eq(1000L));\r\n    }\r\n\r\n    // More misc Tests:\r\n    // Verify that the Sleeper.sleep(2000) call was invoked for a successful attempt:\r\n    @Disabled\r\n    @Test\r\n    void failHandler_callsSleep_onSuccess() throws InterruptedException {\r\n        when(props.getFailSuccSleepTime()).thenReturn(2000L);\r\n        when(fixedRandom.nextDouble()).thenReturn(0.1);\r\n        FailHandler failHandler = new FailHandler(queue, mockSleeper, fixedRandom, props);\r\n        failHandler.handle(t);\r\n        verify(mockSleeper, times(1)).sleep(2000L);\r\n    }\r\n\r\n    // Verify that the Sleeper.sleep(1000) call happened on permanent failure branch:\r\n    @Disabled\r\n    @Test\r\n    void failHandler_callsSleep_onPermFail() throws InterruptedException {\r\n        when(props.getFailSleepTime()).thenReturn(1000L);\r\n        t.setAttempts(3);\r\n        when(fixedRandom.nextDouble()).thenReturn(0.9);\r\n        FailHandler failHandler = new FailHandler(queue, mockSleeper, fixedRandom, props);\r\n        failHandler.handle(t);\r\n        verify(mockSleeper, times(1)).sleep(1000L);\r\n    }\r\n}\r\n",
      "info": {
        "size": 6204,
        "last_modified": "2025-12-12T15:03:50.9434849",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\AuthJwtIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.redis.testcontainers.RedisContainer;\r\nimport com.springqprobackend.springqpro.security.dto.AuthResponse;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.io.Decoders;\r\nimport io.jsonwebtoken.security.Keys;\r\nimport org.junit.jupiter.api.MethodOrderer;\r\nimport org.junit.jupiter.api.Order;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.TestMethodOrder;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.context.ActiveProfiles;\r\nimport org.springframework.test.web.reactive.server.WebTestClient;\r\nimport org.testcontainers.containers.PostgreSQLContainer;\r\nimport org.testcontainers.junit.jupiter.Container;\r\nimport org.testcontainers.junit.jupiter.Testcontainers;\r\nimport org.testcontainers.utility.DockerImageName;\r\n\r\nimport javax.crypto.SecretKey;\r\nimport java.time.Instant;\r\nimport java.util.Date;\r\nimport java.util.Map;\r\nimport static org.assertj.core.api.Assertions.*;\r\n\r\n// THIS IS INTEGRATION TEST FOR THE JWT ASPECT [1] -- for main stuff.\r\n\r\n// 2025-11-26-NOTE: Remember, efficient setup of my Integration Tests are not high priority while I rush to project MVP completion. I can return to this later!\r\n/* 2025-11-26-NOTE(S):\r\n- @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) to load the FULL Spring context like it's a real server.\r\nThis makes sense testing JWT stuff because I want to verify that the security filter chain runs, tokens are parsed, method security\r\nvia @PreAuthorize is enforced, and /graphql and /auth/* behaves like in production. (Want SecurityConfig and so on present).\r\n- @AutoConfigureWebTestClient will set up a WebTestClient to bound to the server. It's as the name implies, basically just\r\nthe dummy HTTP client for testing (use it to hit the HTTP endpoints, send headers, assert status codes, and so on).\r\n- TestMethodOrder(...) is an interesting annotation I should make mental note of and probably use more in the future.\r\nThis basically allows you to control the order of tests which is useful when your tests build upon the same DB. (This can\r\nbe a nice alternative to what I was doing prior, which was flushing the DataBase between tests; this is probably better).\r\n*/\r\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\r\n@AutoConfigureWebTestClient\r\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\r\n@Testcontainers\r\n@ActiveProfiles(\"test\")\r\npublic class AuthJwtIntegrationTest {\r\n    @Autowired\r\n    private WebTestClient webTestClient;\r\n    @Autowired\r\n    private StringRedisTemplate redis;\r\n    @Value(\"${jwt.secret}\")\r\n    private String jwtSecret;   // will be used for test that forges an expired JWT.\r\n\r\n    /* 2025-11-26-NOTE:[BELOW] I AM RUSHING TO MVP COMPLETION, I HAVE GONE SEVERELY OVERTIME WITH THIS PROJECT AND I WANT TO\r\n    WRAP IT UP AS SOON AS POSSIBLE READY FOR PRODUCTION AND DISPLAY FOR RECRUITERS AND READY FOR MY RESUME! THUS, MY\r\n    INTEGRATION TESTS ARE A HOT MESS. I WILL COME BACK IN THE NEAR-FUTURE TO REFACTOR AND TIDY THEM. THE TWO CONTAINERS\r\n    BELOW SHOULD 100% BE MODULARIZED SOMEWHERE -- BUT I AM ON A TIME CRUNCH AND I CAN'T BE ASKED (RIGHT NOW): */\r\n    // DEBUG: BELOW! TEMPORARY - FIX PROPERLY LATER!\r\n    @ServiceConnection\r\n    protected static final PostgreSQLContainer<?> POSTGRES =\r\n            new PostgreSQLContainer<>(\"postgres:18\")\r\n                    .withDatabaseName(\"springqpro\")\r\n                    .withUsername(\"springqpro\")\r\n                    .withPassword(\"springqpro\")\r\n                    .withReuse(true);\r\n    @Container\r\n    @ServiceConnection\r\n    static final RedisContainer REDIS = new RedisContainer(DockerImageName.parse(\"redis:7.2\"));\r\n    // DEBUG: ABOVE! TEMPORARY - FIX PROPERLY LATER!\r\n    /* 2025-11-26-NOTE: AS NOTED IN A COMMENT ABOVE THE CLASS, MY TEST STARTS THE FULL SPRING CONTEXT. BUT DON'T FORGET\r\n    THAT I NEED TO SPIN UP THE REDIS AND POSTGRES CONTAINERS MYSELF!\r\n    NOTE: ALSO, THE @Testcontainers annotation at the top is needed too for this stuff. */\r\n\r\n    // HELPER METHODS (pretty self-explanatory):\r\n    // [1] - Register Attempt:\r\n    private void register(String email, String password) {\r\n        webTestClient.post()\r\n                .uri(\"/auth/register\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\r\n                        \"email\", email,\r\n                        \"password\", password\r\n                ))\r\n                .exchange()\r\n                .expectStatus().isCreated();\r\n    }\r\n\r\n    // [2] - Login Attempt:\r\n    private AuthResponse login(String email, String password) {\r\n        return webTestClient.post()\r\n                .uri(\"/auth/login\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\r\n                        \"email\", email,\r\n                        \"password\", password\r\n                ))\r\n                .exchange()\r\n                .expectStatus().isOk()\r\n                .expectBody(AuthResponse.class)\r\n                .returnResult()\r\n                .getResponseBody();\r\n    }\r\n\r\n    // [3] - Sending a GraphQL query with authenticataion token:\r\n    private WebTestClient.ResponseSpec graphQLWithToken(String token, String query) {\r\n        return webTestClient.post()\r\n                .uri(\"/graphql\")\r\n                .header(HttpHeaders.AUTHORIZATION, \"Bearer \" + token)\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\"query\", query))\r\n                .exchange();\r\n    }\r\n\r\n    // TESTS:\r\n    @Test\r\n    @Order(1)\r\n    // NOTE: Related to the enforcing order thing.\r\n    void fullLoginFlow_shouldAllowAccessToProtectedGraphQL() {\r\n        String email = \"random_email@gmail.com\";\r\n        String password = \"i_am_wanted_in_delaware\";\r\n\r\n        // 1. Register:\r\n        register(email, password);\r\n        // 2. Login and get tokens:\r\n        AuthResponse auth = login(email, password);\r\n        assertThat(auth).isNotNull();\r\n        assertThat(auth.accessToken()).isNotBlank();\r\n        assertThat(auth.refreshToken()).isNotBlank();\r\n\r\n        String accessToken = auth.accessToken();\r\n\r\n        // 3. Call protected GraphQL with access token\r\n        String query = \"\"\"\r\n                query {\r\n                  tasks {\r\n                    id\r\n                    status\r\n                  }\r\n                }\r\n                \"\"\";\r\n\r\n        graphQLWithToken(accessToken, query)\r\n                .expectStatus().isOk()\r\n                .expectBody()\r\n                .jsonPath(\"$.data.tasks\").exists();\r\n    }\r\n\r\n    @Test\r\n    @Order(2)\r\n        // This is why enforcing order is useful. I want this Test to execute after the one above.\r\n    void registerAttempt_shouldFail_forExistingEmail() {\r\n        String email = \"random_email@gmail.com\";\r\n        String password = \"I smell bad\";\r\n        // Second registration attempt (no real easy way to test for exception thrown apart from duplicating the register method logic w/ fail adjustment):\r\n        webTestClient.post()\r\n                .uri(\"/auth/register\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\r\n                        \"email\", email,\r\n                        \"password\", password\r\n                ))\r\n                .exchange()\r\n                .expectStatus().isEqualTo(HttpStatus.CONFLICT)\r\n                .expectBody()\r\n                .jsonPath(\"$.status\").doesNotExist();\r\n    }\r\n\r\n    @Test\r\n    @Order(3)\r\n    void refreshFlow_shouldRotateRefreshToken_andInvalidateOldRefresh() {\r\n\r\n        //REDIS.getRequiredConnectionFactory().getConnection().serverCommands().flushAll();\r\n        /*redis.execute((RedisConnection connection) -> {\r\n            connection.serverCommands().flushAll();\r\n            return null;\r\n        });*/ // <-- FLUSH JUST FOR THIS TEST FOR NOW...\r\n\r\n        String email = \"jwt_refresh@gmail.com\";\r\n        String password = \"I need a shower\";\r\n        register(email, password);\r\n        AuthResponse auth = login(email, password);\r\n        String oldAccess = auth.accessToken();\r\n        String oldRefresh = auth.refreshToken();\r\n        // Call /auth/refresh w/ old refresh token:\r\n        AuthResponse refreshed = webTestClient.post()\r\n                .uri(\"/auth/refresh\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\"refreshToken\", oldRefresh))\r\n                .exchange()\r\n                .expectStatus().isOk()\r\n                .expectBody(AuthResponse.class)\r\n                .returnResult()\r\n                .getResponseBody();\r\n        // Making sure I get something new:\r\n        assertThat(refreshed).isNotNull();\r\n        assertThat(refreshed.accessToken()).isNotBlank();\r\n        assertThat(refreshed.refreshToken()).isNotBlank();\r\n        assertThat(refreshed.accessToken()).isNotEqualTo(oldAccess);\r\n        assertThat(refreshed.refreshToken()).isNotEqualTo(oldRefresh);\r\n        // Plugging in the old values won't work now thanks to rotation:\r\n        webTestClient.post()\r\n                .uri(\"/auth/refresh\")\r\n                .bodyValue(Map.of(\"refreshToken\", oldRefresh))\r\n                .exchange()\r\n                .expectStatus().isUnauthorized();\r\n    }\r\n\r\n    @Test\r\n    @Order(4)\r\n    void logout_shouldInvalidate_refreshToken() {\r\n        String email = \"jwt_logout@gmail.com\";\r\n        String password = \"I have a DUI in six different states\";\r\n        register(email, password);\r\n        AuthResponse auth = login(email, password);\r\n        String refresh = auth.refreshToken();\r\n        // Logout:\r\n        webTestClient.post()\r\n                .uri(\"/auth/logout\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\"refreshToken\", refresh))\r\n                .exchange()\r\n                .expectStatus().isOk()\r\n                .expectBody()\r\n                .jsonPath(\"$.status\").isEqualTo(\"logged out\");\r\n        // Now an attempt to refresh with the same token (meant to fail):\r\n        webTestClient.post()\r\n                .uri(\"/auth/refresh\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\"refreshToken\", refresh))\r\n                .exchange()\r\n                .expectStatus().isUnauthorized()\r\n                .expectBody()\r\n                .jsonPath(\"$.error\").isEqualTo(\"Invalid or expired refresh token\");\r\n    }\r\n\r\n    @Test\r\n    @Order(5)\r\n    void expiredJwtToken_shouldBeRejected_ForGraphQL() {\r\n        // Make expired JWT manually using my secret key:\r\n        byte[] keyBytes = Decoders.BASE64.decode(jwtSecret);\r\n        SecretKey key = Keys.hmacShaKeyFor(keyBytes);\r\n        Instant now = Instant.now();\r\n        Date pastIssuedAt = Date.from(now.minusSeconds(3600));  // 1 hour ago. (issued).\r\n        Date pastExpiration = Date.from(now.minusSeconds(1800)); // expired 30 minutes ago.\r\n        String expiredToken = Jwts.builder()\r\n                .subject(\"expired-user@example.com\")\r\n                .issuedAt(pastIssuedAt)\r\n                .expiration(pastExpiration)\r\n                .signWith(key)\r\n                .compact();\r\n        String query = \"\"\"\r\n                query {\r\n                  tasks {\r\n                    id\r\n                  }\r\n                }\r\n                \"\"\";\r\n\r\n        // Because SecurityConfig requires authentication on /graphql, expired token will be caught by resolvers, send back 401, and so on.\r\n        webTestClient.post()\r\n                .uri(\"/graphql\")\r\n                .header(HttpHeaders.AUTHORIZATION, \"Bearer \" + expiredToken)\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\"query\", query))\r\n                .exchange()\r\n                .expectStatus().isForbidden();\r\n    }\r\n}\r\n",
      "info": {
        "size": 12357,
        "last_modified": "2025-12-12T15:03:50.9590312",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\CreateAndProcessTaskIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport com.springqprobackend.springqpro.testcontainers.IntegrationTestBase;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Disabled;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.web.client.TestRestTemplate;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.testcontainers.shaded.org.awaitility.Awaitility;\r\n\r\nimport java.time.Duration;\r\nimport java.util.Map;\r\nimport java.util.Optional;\r\n\r\nimport static org.assertj.core.api.Assertions.*;\r\n\r\n// 2025-11-30: This Integration Test is testing outdated architecture. Keeping it for now because it should be noted in my documentation.\r\n\r\n/* NOTE(S)-TO-SELF:\r\n- @Testcontainers enables Container Lifecycle Support in JUnit.\r\n- @SpringBootTest is \"useful when you need to bootstrap the entire container. This annotation works by\r\ncreating the ApplicationContext that will be utilized in our tests.\" (Arguments are pretty straightforward).\r\n- @Container provides a Docker container to manage for the Test Class.\r\n- @DynamicPropertySource is an annotation that can be applied to methods in Integration Test classes that need to\r\nregister dynamic properties to be added to the set of PropertySources in the Environment for an ApplicationContext loaded for an Int Test.\r\n- TestRestTemplate is a utility class designed for Int Testing of RESTful services. It extends RestTemplate and\r\nprovides a convenient way to make HTTP Requests within my tests (esp when using an embedded server w/ @SpringBootTest).\r\n^ [This was the definition Google AI Overview provided, but sounds about right].\r\n*/\r\n\r\n/* TO-DO:+NOTE: Maybe instead of using Awaitility, see if I can do something similar as to before w/ manually configured\r\nExecutors to skip the processing time? I have no idea if I can do that with Integration Tests. Honestly, probably not, but look into it.\r\n*/\r\n\r\n/* TO-DO:+NOTE:+GPT Suggestion: I could have a \"Scheduled Queue Scanner\" that finds stuck QUEUED Tasks every X seconds:\r\n\"@Scheduled(fixedDelay = 2000)\r\npublic void sweepQueuedTasks() {\r\n    List<String> ids = taskRepository.findQueuedTaskIds();\r\n    ids.forEach(queueService::enqueueById);\r\n}\" <-- That is what Kafka consumers, SQS workers, and Airflow do. (So this is a more cloud-native solution, but figure things out deeper later).\r\n*/\r\n\r\n/* This method here basically:\r\n1. Boots up the Spring context with a PostgreSQL Testcontainer.\r\n2. Calls the REST endpoint w/ TestRestTemplate to create a Task (this will persist the TaskEntity and enqueue w/ TaskService).\r\n3. Waits (w/ Awaitility) for the DB row to become COMPLETED verifying that the ProcessingService ran and handler executed, status persisted.\r\n- Uses Awaitility to wait for ProcessingService's asynchronous processing.\r\n*/\r\n//@Testcontainers\r\n//@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\r\nclass CreateAndProcessTaskIntegrationTest extends IntegrationTestBase {\r\n    @Autowired\r\n    private TestRestTemplate rest;\r\n\r\n    @Autowired\r\n    private TaskRepository taskRepository;\r\n\r\n    @BeforeEach\r\n    void cleanDb() {\r\n        taskRepository.deleteAll();\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void createTask_isPersisted_andEventuallyProcessed() {\r\n        // Starting w/ creating Task via REST endpoint (my ProducerController's POST /enqueue):\r\n        Map<String, Object> req = Map.of(\"payload\", \"integration-test\", \"type\", \"EMAIL\");\r\n        ResponseEntity<Map> response = rest.postForEntity(\"/api/enqueue\", req, Map.class);\r\n        assertThat(response.getStatusCode().is2xxSuccessful());\r\n\r\n        /* After the Request is enqueued, that Task is saved to the DataBase and sent to the in-memory QueueService pool.\r\n        To make sure that the Task was persisted, we can check the most recent row in our DB: */\r\n        Awaitility.await()\r\n                .atMost(Duration.ofSeconds(5))\r\n                .pollInterval(Duration.ofMillis(200))\r\n                .untilAsserted(()-> {\r\n                    // No point if the Task Repository is empty (no rows).\r\n                    Iterable<TaskEntity> all = taskRepository.findAll();\r\n                    assertThat(all).isNotEmpty();\r\n                });\r\n        // Retrieving the first row:\r\n        TaskEntity entity = taskRepository.findAll().iterator().next();\r\n        assertThat(entity.getPayload()).isEqualTo(\"integration-test\");\r\n        // Wait for processing to finish\r\n        Awaitility.await()\r\n                .atMost(Duration.ofSeconds(10))\r\n                .pollInterval(Duration.ofMillis(300))\r\n                .until(() -> {\r\n                    Optional<TaskEntity> refreshed = taskRepository.findById(entity.getId());\r\n                    return refreshed.map(e -> e.getStatus() == TaskStatus.COMPLETED || e.getStatus() == TaskStatus.FAILED).orElse(false);\r\n                });\r\n    }\r\n}\r\n",
      "info": {
        "size": 5141,
        "last_modified": "2025-12-12T15:03:50.966794",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\OwnershipGraphQLIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\n// THIS IS INTEGRATION TEST FOR THE JWT ASPECT [2] -- for task ownership and that stuff.\r\n\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.redis.testcontainers.RedisContainer;\r\nimport com.springqprobackend.springqpro.security.dto.AuthResponse;\r\nimport org.junit.jupiter.api.MethodOrderer;\r\nimport org.junit.jupiter.api.Order;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.TestMethodOrder;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.context.ActiveProfiles;\r\nimport org.springframework.test.web.reactive.server.WebTestClient;\r\nimport org.testcontainers.containers.PostgreSQLContainer;\r\nimport org.testcontainers.junit.jupiter.Container;\r\nimport org.testcontainers.junit.jupiter.Testcontainers;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.testcontainers.utility.DockerImageName;\r\n\r\nimport java.util.Map;\r\nimport static org.assertj.core.api.Assertions.*;\r\n\r\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\r\n@AutoConfigureWebTestClient\r\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\r\n@Testcontainers\r\n@ActiveProfiles(\"test\")\r\npublic class OwnershipGraphQLIntegrationTest {\r\n    // Field(s):\r\n    @Autowired\r\n    private WebTestClient webTestClient;\r\n    @Autowired\r\n    private ObjectMapper objectMapper;\r\n\r\n    /* 2025-11-26-NOTE:[BELOW] I AM RUSHING TO MVP COMPLETION, I HAVE GONE SEVERELY OVERTIME WITH THIS PROJECT AND I WANT TO\r\n    WRAP IT UP AS SOON AS POSSIBLE READY FOR PRODUCTION AND DISPLAY FOR RECRUITERS AND READY FOR MY RESUME! THUS, MY\r\n    INTEGRATION TESTS ARE A HOT MESS. I WILL COME BACK IN THE NEAR-FUTURE TO REFACTOR AND TIDY THEM. THE TWO CONTAINERS\r\n    BELOW SHOULD 100% BE MODULARIZED SOMEWHERE -- BUT I AM ON A TIME CRUNCH AND I CAN'T BE ASKED (RIGHT NOW): */\r\n    // DEBUG: BELOW! TEMPORARY - FIX PROPERLY LATER!\r\n    @ServiceConnection\r\n    protected static final PostgreSQLContainer<?> POSTGRES =\r\n            new PostgreSQLContainer<>(\"postgres:18\")\r\n                    .withDatabaseName(\"springqpro\")\r\n                    .withUsername(\"springqpro\")\r\n                    .withPassword(\"springqpro\")\r\n                    .withReuse(true);\r\n    @Container\r\n    @ServiceConnection\r\n    static final RedisContainer REDIS = new RedisContainer(DockerImageName.parse(\"redis:7.2\"));\r\n    // DEBUG: ABOVE! TEMPORARY - FIX PROPERLY LATER!\r\n    /* 2025-11-26-NOTE: AS NOTED IN A COMMENT ABOVE THE CLASS, MY TEST STARTS THE FULL SPRING CONTEXT. BUT DON'T FORGET\r\n    THAT I NEED TO SPIN UP THE REDIS AND POSTGRES CONTAINERS MYSELF!\r\n    NOTE: ALSO, THE @Testcontainers annotation at the top is needed too for this stuff. */\r\n\r\n    // For the tests:\r\n    private static String aliceToken;\r\n    private static String simonToken;\r\n    private static String aliceTaskId;\r\n    private static String simonTaskId;\r\n    private static final String password = \"who_cares\";\r\n    private static final String alice_email = \"alice@gmail.com\";\r\n    private static final String simon_email = \"simon@gmail.com\";\r\n\r\n    // HELPER METHODS (again, there's a lot of repeated boilerplate code here and in the other JWT test file -- modularize later, I'm rushing):\r\n    // [1] - REGISTER:\r\n    private void register(String email, String password) {\r\n        webTestClient.post()\r\n                .uri(\"/auth/register\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\r\n                        \"email\", email,\r\n                        \"password\", password\r\n                ))\r\n                .exchange()\r\n                .expectStatus().isCreated();\r\n    }\r\n    // [2] - LOGIN:\r\n    private AuthResponse login(String email, String password) {\r\n        return webTestClient.post()\r\n                .uri(\"/auth/login\")\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\r\n                        \"email\", email,\r\n                        \"password\", password\r\n                ))\r\n                .exchange()\r\n                .expectStatus().isOk()\r\n                .expectBody(AuthResponse.class)\r\n                .returnResult()\r\n                .getResponseBody();\r\n    }\r\n    // [3] - GRAPHQL QUERY:\r\n    private String graphQLQuery(String token, String query) {\r\n        return webTestClient.post()\r\n                .uri(\"/graphql\")\r\n                .header(HttpHeaders.AUTHORIZATION, \"Bearer \" + token)\r\n                .contentType(MediaType.APPLICATION_JSON)\r\n                .bodyValue(Map.of(\"query\", query))\r\n                .exchange()\r\n                .expectStatus().isOk()\r\n                .expectBody(String.class)\r\n                .returnResult()\r\n                .getResponseBody();\r\n    }\r\n    // [4] - CREATE TASK (for specific User):\r\n    private String createTaskForUser(String token, String payload, String type) throws Exception {\r\n        String mutation = \"\"\"\r\n                mutation {\r\n                  createTask(input: { payload: \"%s\", type: %s }) {\r\n                    id\r\n                    status\r\n                  }\r\n                }\r\n                \"\"\".formatted(payload, type);\r\n        String json = graphQLQuery(token, mutation);\r\n        JsonNode root = objectMapper.readTree(json);\r\n        JsonNode idNode = root.path(\"data\").path(\"createTask\").path(\"id\");\r\n        assertThat(idNode.isMissingNode()).isFalse();\r\n        return idNode.asText();\r\n    }\r\n\r\n    // TESTS (they'll work in sequence with enforced ordering. When I refactor and clean things up, this ordering stays):\r\n    // Test #1 - Setup: Register both users, login, and then store tokens:\r\n    @Test\r\n    @Order(1)\r\n    void registerTestUsers_andLogin_thenStoreTokens() {\r\n        register(alice_email, password); // Register Alice.\r\n        register(simon_email, password); // Register Simon.\r\n        // Login and then record tokens in the global variables.\r\n        AuthResponse aliceAuth = login(alice_email, password);\r\n        AuthResponse simonAuth = login(simon_email, password);\r\n        aliceToken = aliceAuth.accessToken();\r\n        simonToken = simonAuth.accessToken();\r\n        // Make sure the login worked and returned tokens basically:\r\n        assertThat(aliceToken).isNotBlank();\r\n        assertThat(simonToken).isNotBlank();\r\n    }\r\n\r\n    // Test #2 - Alice creates a task and can see it.\r\n    @Test\r\n    @Order(2)\r\n    void userOne_CreatesTask_andCanSeeIt() throws Exception {\r\n        aliceTaskId = createTaskForUser(aliceToken, \"Alice send email\", \"EMAIL\");\r\n        assertThat(aliceTaskId).isNotBlank();\r\n        String json = graphQLQuery(aliceToken, \"\"\"\r\n                query {\r\n                  tasks {\r\n                    id\r\n                    status\r\n                  }\r\n                }\r\n                \"\"\");\r\n        JsonNode root = objectMapper.readTree(json);\r\n        JsonNode arr = root.path(\"data\").path(\"tasks\");\r\n        assertThat(arr.isArray()).isTrue();\r\n        assertThat(arr.size()).isGreaterThanOrEqualTo(1);\r\n        boolean found = false;\r\n        for (JsonNode t : arr) {\r\n            if (aliceTaskId.equals(t.path(\"id\").asText())) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        assertThat(found).isTrue();\r\n    }\r\n\r\n    // Test #3 - Simon cannot see Alice's created task.\r\n    @Test\r\n    @Order(3)\r\n    void userTwo_cannotSee_priorTask() throws Exception {\r\n        String json = graphQLQuery(simonToken, \"\"\"\r\n                query {\r\n                  tasks {\r\n                    id\r\n                    status\r\n                  }\r\n                }\r\n                \"\"\");\r\n        JsonNode root = objectMapper.readTree(json);\r\n        JsonNode arr  = root.path(\"data\").path(\"tasks\");\r\n        assertThat(arr.isArray()).isTrue();\r\n        for (JsonNode t : arr) {\r\n            assertThat(t.path(\"id\").asText()).isNotEqualTo(aliceTaskId);\r\n        }\r\n    }\r\n\r\n    // Test #4 - Simon cannot fetch Alice's task by ID.\r\n    @Test\r\n    @Order(4)\r\n    void userTwo_cannotFetch_priorTaskById() throws Exception {\r\n        String json = graphQLQuery(simonToken, \"\"\"\r\n                query {\r\n                  task(id: \"%s\") {\r\n                    id\r\n                    status\r\n                  }\r\n                }\r\n                \"\"\".formatted(aliceTaskId));\r\n        JsonNode root = objectMapper.readTree(json);\r\n        JsonNode node = root.path(\"data\").path(\"task\");\r\n        assertThat(node.isNull()).isTrue();\r\n    }\r\n\r\n    // Test #5 - Simon cannot update Alice's task.\r\n    @Test\r\n    @Order(5)\r\n    void userTwo_cannotUpdate_priorTask() throws Exception {\r\n        String mutation = \"\"\"\r\n                mutation {\r\n                  updateTask(input: {\r\n                    id: \"%s\",\r\n                    status: COMPLETED,\r\n                    attempts: 999\r\n                  }) {\r\n                    id\r\n                    status\r\n                  }\r\n                }\r\n                \"\"\".formatted(aliceTaskId);\r\n        String json = graphQLQuery(simonToken, mutation);\r\n        JsonNode root = objectMapper.readTree(json);\r\n        JsonNode dataNode = root.path(\"data\").path(\"updateTask\");\r\n        assertThat(dataNode.isNull()).isTrue();\r\n        JsonNode errors = root.path(\"errors\");\r\n        assertThat(errors.isMissingNode() || errors.isArray()).isTrue();\r\n    }\r\n}\r\n",
      "info": {
        "size": 9713,
        "last_modified": "2025-12-12T15:03:50.976885",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\ProcessingConcurrencyIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.redis.RedisDistributedLock;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport com.springqprobackend.springqpro.service.ProcessingService;\r\nimport com.springqprobackend.springqpro.service.TaskService;\r\nimport com.springqprobackend.springqpro.testcontainers.IntegrationTestBase;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.junit.jupiter.api.Test;\r\nimport java.util.concurrent.*;\r\n\r\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\r\n\r\n/* DESCRIPTION OF THIS TEST CASE:\r\n- Simulates two concurrent threads trying to claim the same persisted Task.\r\n- Verifies that only one claim succeeds by asserting attempts is 1 after concurrent calls\r\n(the transitionStatus pattern should prevent double-claim).\r\n- Basically checks the atomicity of the DB-level Task claim (transitionStatus(...) mainly)\r\nand checks the functionality I have in place to make sure that a Task cannot be simultaneously processed.\r\n*/\r\n/* 2025-11-17-NOTE:\r\nThese three Integration test that I have (ProcessingConcurrencyIntegrationTest.java, CreateAndProcessTaskIntegrationTest.java,\r\nand RetryBehaviorIntegrationTest.java) are broad enough to cover the core functionality of my ProcessingService.java-related\r\narchitectural overhaul.\r\n[Granted, here are some other things I can write tests for when I'm not on a time crunch]:\r\n*More so tests to write under this new architectural overhaul*\r\nTask Lifecycle Tests:\r\n- Test Task Transitions across all handlers (EMAIL, NEWSLETTER, SMS, and so on).\r\n- Test Handler-induced InterruptException produces correct FAILED and retry behavior.\r\nQueueService behavior:\r\n- Test enqueuing with delay, ensuring delayed tasks will only start after minimum time.\r\n- Test that multiple delayed tasks do not block each other.\r\nPersistence + Mapping layer:\r\n- Test Task -> TaskEntity -> Task mapping round-trip (ensure payload, timestamps, and attempts to remain consistent).\r\nTest queries:\r\n- findTop5ByStatusOrderByCreatedAtAsc <-- stuff like this\r\nShutdown/Restart behavior:\r\n- Maybe better off once I implement Redis.\r\n- Making sure persisted tasks still resume processing on application restart.\r\nGRAPHQL-RELATED QUERIES:\r\n- Pagination Queries\r\n- Query for Tasks by Status\r\n- Mutation for creating tasks\r\n- Testing n+1 fetches mitigated by DataLoader (maybe if integrated).\r\n*/\r\n//@Testcontainers\r\n//@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)\r\nclass ProcessingConcurrencyIntegrationTest extends IntegrationTestBase {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(ProcessingConcurrencyIntegrationTest.class);\r\n    @Autowired\r\n    private TaskService taskService;\r\n    @Autowired\r\n    private TaskRepository taskRepository;\r\n    @Autowired\r\n    private ProcessingService processingService;\r\n    @Autowired\r\n    private RedisDistributedLock redisLock;\r\n\r\n    @BeforeEach\r\n    void cleanDb() {\r\n        taskRepository.deleteAll();\r\n    }\r\n\r\n    @Test\r\n    void twoThreads_tryToClaim_sameTask_onlyOneSucceeds() throws InterruptedException, ExecutionException {\r\n        TaskEntity entity = taskService.createTaskForUser(\"concurrency-test\", TaskType.EMAIL, \"random_email@gmail.com\");\r\n        String id = entity.getId();\r\n        ExecutorService esDummy = Executors.newFixedThreadPool(2);\r\n        Callable<Void> c = () -> {\r\n            processingService.claimAndProcess(id);\r\n            return null;\r\n        };\r\n        Future<Void> f1 = esDummy.submit(c);\r\n        Future<Void> f2 = esDummy.submit(c);\r\n        f1.get();\r\n        f2.get();\r\n        // reload:\r\n        TaskEntity reloaded = taskRepository.findById(id).orElseThrow();\r\n        // ATTEMPTS SHOULD BE 1.\r\n        assertThat(reloaded.getAttempts()).isEqualTo(1);\r\n        assertThat(reloaded.getStatus()).isNotNull();   // No double-claiming anomalies or corrupted states.\r\n        esDummy.shutdown();\r\n    }\r\n}\r\n",
      "info": {
        "size": 4239,
        "last_modified": "2025-12-12T15:03:50.976885",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\RedisDistributedLockIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.redis.testcontainers.RedisContainer;\r\nimport com.springqprobackend.springqpro.config.RedisTestConfig;\r\nimport com.springqprobackend.springqpro.redis.RedisDistributedLock;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;\r\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\r\nimport org.springframework.context.annotation.Import;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.test.context.TestPropertySource;\r\nimport org.springframework.test.context.junit.jupiter.SpringJUnitConfig;\r\nimport org.testcontainers.junit.jupiter.Container;\r\nimport org.testcontainers.junit.jupiter.Testcontainers;\r\nimport org.testcontainers.utility.DockerImageName;\r\nimport static org.assertj.core.api.Assertions.*;\r\n\r\n// NOTE: REDIS TEST\r\n\r\n@DataRedisTest\r\n@Testcontainers\r\n@SpringJUnitConfig\r\n@Import({ RedisTestConfig.class, RedisDistributedLock.class })\r\n@TestPropertySource(properties = {\r\n        \"spring.profiles.active=test\"\r\n})\r\npublic class RedisDistributedLockIntegrationTest {\r\n    @Container\r\n    @ServiceConnection\r\n    static final RedisContainer REDIS =\r\n            new RedisContainer(DockerImageName.parse(\"redis:7.2\"));\r\n    @Autowired\r\n    private RedisDistributedLock lock;\r\n    @Autowired\r\n    private StringRedisTemplate stringRedis;\r\n\r\n    private static final String LOCK_KEY = \"lock:test-item\";\r\n\r\n    @BeforeEach\r\n    void cleanUp() {\r\n        stringRedis.getRequiredConnectionFactory()\r\n                .getConnection()\r\n                .serverCommands()\r\n                .flushAll();\r\n    }\r\n\r\n    @Test\r\n    void testAcquireLock_whenFree_shouldSucceed() {\r\n        String token = lock.tryLock(LOCK_KEY, 2000);\r\n        assertThat(token).isNotNull();\r\n        // Verify key exists:\r\n        String raw = stringRedis.opsForValue().get(LOCK_KEY);\r\n        System.out.println(\"DEBUG: The value of raw => \" + raw);\r\n        assertThat(raw).isEqualTo(token);\r\n    }\r\n    @Test\r\n    void testAcquireLock_whenAlreadyLocked_shouldFail() {\r\n        String token1 = lock.tryLock(LOCK_KEY, 2000);\r\n        assertThat(token1).isNotNull();\r\n        // Verify lock:\r\n        String token2 = lock.tryLock(LOCK_KEY, 2000);\r\n        assertThat(token2).isNull(); // second lock must fail\r\n    }\r\n\r\n    @Test\r\n    void testUnlock_withCorrectToken_shouldSucceed() {\r\n        String token = lock.tryLock(LOCK_KEY, 2000);\r\n        assertThat(token).isNotNull();\r\n        boolean released = lock.unlock(LOCK_KEY, token);\r\n        assertThat(released).isTrue();\r\n        // Ensure lock is gone:\r\n        String raw = stringRedis.opsForValue().get(LOCK_KEY);\r\n        assertThat(raw).isNull();\r\n    }\r\n\r\n    @Test\r\n    void testUnlock_withWrongToken_shouldFail() {\r\n        String token = lock.tryLock(LOCK_KEY, 2000);\r\n        assertThat(token).isNotNull();\r\n        boolean released = lock.unlock(LOCK_KEY, \"WRONG-TOKEN\");\r\n        assertThat(released).isFalse();\r\n        // Lock must STILL exist:\r\n        String raw = stringRedis.opsForValue().get(LOCK_KEY);\r\n        assertThat(raw).isEqualTo(token);\r\n    }\r\n\r\n    @Test\r\n    void testLockExpires_afterTTL() throws InterruptedException {\r\n        String token = lock.tryLock(LOCK_KEY, 250); // 250ms TTL\r\n        assertThat(token).isNotNull();\r\n        // Key should exist immediately\r\n        assertThat(stringRedis.opsForValue().get(LOCK_KEY)).isEqualTo(token);\r\n        // Wait for TTL to expire\r\n        Thread.sleep(350);  // NOTE:+TO-DO: Change this to something more professional later I'm rushing.\r\n        // Key should be gone\r\n        assertThat(stringRedis.opsForValue().get(LOCK_KEY)).isNull();\r\n        // New lock should now succeed\r\n        String token2 = lock.tryLock(LOCK_KEY, 1000);\r\n        assertThat(token2).isNotNull();\r\n    }\r\n}\r\n",
      "info": {
        "size": 4010,
        "last_modified": "2025-12-12T15:03:50.9948293",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\RedisPingIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.redis.testcontainers.RedisContainer;\r\nimport com.springqprobackend.springqpro.config.RedisTestConfig;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;\r\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\r\nimport org.springframework.context.annotation.Import;\r\nimport org.springframework.data.redis.core.RedisCallback;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.test.context.DynamicPropertyRegistry;\r\nimport org.springframework.test.context.DynamicPropertySource;\r\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\r\nimport org.testcontainers.containers.GenericContainer;\r\nimport org.testcontainers.junit.jupiter.Container;\r\nimport org.testcontainers.junit.jupiter.Testcontainers;\r\nimport org.testcontainers.utility.DockerImageName;\r\n\r\n// NOTE: REDIS TEST\r\n\r\n//@ContextConfiguration(classes = { RedisPingIntegrationTest.Config.class })\r\n//@Import(RedisTestConfig.class)\r\n@DataRedisTest\r\n@Testcontainers\r\n@ExtendWith(SpringExtension.class)\r\nclass RedisPingIntegrationTest {\r\n    @Container\r\n    @ServiceConnection\r\n    static final RedisContainer REDIS =\r\n            new RedisContainer(DockerImageName.parse(\"redis:7.2\"));\r\n\r\n    @Autowired\r\n    private StringRedisTemplate stringRedisTemplate;\r\n\r\n    @Test\r\n    void testPing() {\r\n        String result = stringRedisTemplate.execute((RedisCallback<String>) (conn) -> conn.ping());\r\n        assert result.equalsIgnoreCase(\"PONG\");\r\n    }\r\n}",
      "info": {
        "size": 1741,
        "last_modified": "2025-12-12T15:03:50.9948293",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\RetryBehaviorIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.springqprobackend.springqpro.domain.exception.TaskProcessingException;\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.handlers.TaskHandler;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport com.springqprobackend.springqpro.repository.UserRepository;\r\nimport com.springqprobackend.springqpro.service.TaskService;\r\nimport com.springqprobackend.springqpro.testcontainers.IntegrationTestBase;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Disabled;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.boot.test.context.TestConfiguration;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Primary;\r\nimport org.testcontainers.shaded.org.awaitility.Awaitility;\r\n\r\nimport java.time.Duration;\r\nimport static org.assertj.core.api.Assertions.*;\r\n\r\n/* DESCRIPTION OF THIS TEST CASE:\r\n- Ensures that a Handler that is marked to fail (FailHandler is overridden so its handle() method throws immediately)\r\ncauses ProcessingService to schedule a retry (and that attempts are incremented, which basically serves as proof).\r\n- FailHandler is overridden so its handle() method throws immediately, this was done for deterministic test behavior.\r\n*/\r\n\r\n/* NOTE(S)-TO-SELF:\r\n- @TestConfiguration is a specialized version of @Configuration designed specifically for defining beans\r\nand customizations in a test environment. Meant to provide test-specific configurations without interfering\r\nwith the auto-detection of @SpringBootConfiguration (your app's primary config). [Google AI Overview, but sounds good]\r\n- @SpyBean is a Spring Boot testing annotation that integrates Mockito's spying capabilities within a Spring ApplicationContext.\r\nIt is specifically designed for integration tests where you need to interact with Spring-managed beans.\r\n-- Unlike @Spy (a pure Mockito annotation for non-Spring objects), @SpyBean targets beans managed by the Spring container.\r\n-- @SpyBean lets you crete a spy that wraps an existing Spring bean. This means you can selectively mock certain methods of the\r\nbean for testing purposes while allowing other methods to execute their real implementations.\r\n-- @SpyBean is primarily used in Spring Boot Integration Tests [like this one] to isolate parts of my application and\r\ntest specific interactions between beans.\r\n-- If a Bean of the required type already exists in the ApplicationContext, @SpyBean will wrap it up in a spy.\r\nAnd if no such bean exists, it will create a new instance of the bean and then wrap it with a spy.\r\n-- When used on a field in a test class, the created spy will also be injected into that field, allowing you to interact\r\nwith it directly in your test methods. [And all of this on @SpyBean was taken from Google AI Overview, but seems legit]\r\n*/\r\n// 2025-11-17-EDIT: This Test Case is poorly implemented and won't work because it don't account for my backoffMs delay thing in ProcessingService.java !!!\r\n//@Testcontainers\r\n//@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE, properties = \"spring.main.allow-bean-definition-overriding=true\")\r\n@SpringBootTest(\r\n        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,\r\n        properties = \"spring.main.allow-bean-definition-overriding=true\"\r\n)\r\nclass RetryBehaviorIntegrationTest extends IntegrationTestBase {\r\n    // Field(s):\r\n    private static final Logger logger = LoggerFactory.getLogger(RetryBehaviorIntegrationTest.class);\r\n\r\n    @Autowired\r\n    private TaskService taskService;\r\n    @Autowired\r\n    private TaskRepository taskRepository;\r\n    @Autowired\r\n    private UserRepository userRepository;\r\n\r\n    // Inject deterministic test handler for FAIL type in place of the real FailHandler class.\r\n    @TestConfiguration\r\n    static class DeterministicFailHandler {\r\n        @Bean(name=\"FAIL\")  // FIX(?): Need to match FailHandler's @Component(\"FAIL\")\r\n        @Primary\r\n        public TaskHandler detFailHandler() {\r\n            return task -> {\r\n                logger.info(\"DEBUG: ABOUT TO THROW NEW TASKPROCESSINGEXCEPTION!\");\r\n                throw new TaskProcessingException(\"Intentional fail for retry simulation [this time literally as part of the Integration Tests]\");\r\n            };\r\n        }\r\n    }\r\n\r\n    @BeforeEach\r\n    void cleanDb() {\r\n        taskRepository.deleteAll();\r\n        if (!userRepository.existsById(\"retrytest@example.com\")) {\r\n            userRepository.save(new com.springqprobackend.springqpro.domain.entity.UserEntity(\r\n                    \"retrytest@example.com\",\r\n                    \"{noop}password\"     // encoder is irrelevant: we never authenticate in this test\r\n            ));\r\n        }\r\n    }\r\n\r\n    // 2025-11-30-NOTE: Test below is architecturally outdated.\r\n    // 2025-11-17-DEBUG: Renaming the Test name. (Checking that it's QUEUED is more accurate than checking if it's FAILED).\r\n    //@Disabled\r\n    @Test\r\n    void failingTask_isRequeued_andRetryScheduled() {\r\n        // 1. MAKE TASK:\r\n        TaskEntity entity = taskService.createTaskForUser(\"RETRY TEST\", TaskType.FAIL, \"random_email@gmail.com\");\r\n        String id = entity.getId();\r\n\r\n        // WAIT FOR FIRST FAILURE:\r\n        Awaitility.await().atMost(Duration.ofSeconds(5)).pollInterval(Duration.ofMillis(250)).untilAsserted(() -> {\r\n            TaskEntity e = taskRepository.findById(id).orElseThrow();\r\n            assertThat(e.getStatus()).isEqualTo(TaskStatus.QUEUED); // <-- EDIT: Pretty sure this should actually check to see if it was QUEUED and not FAILED (to imply that requeue is coming).\r\n            assertThat(e.getAttempts()).isGreaterThanOrEqualTo(1);\r\n        });\r\n        // WAIT FOR REQUEUE + SECOND ATTEMPT -> ATTEMPTS INCREASED:\r\n        Awaitility.await().atMost(Duration.ofSeconds(10)).pollInterval(Duration.ofMillis(250)).untilAsserted(() -> {\r\n            TaskEntity e = taskRepository.findById(id).orElseThrow();\r\n            assertThat(e.getAttempts()).isGreaterThanOrEqualTo(2);\r\n        });\r\n    }\r\n}\r\n",
      "info": {
        "size": 6422,
        "last_modified": "2025-12-12T15:03:51.0105589",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\TaskCacheIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.redis.testcontainers.RedisContainer;\r\nimport com.springqprobackend.springqpro.config.RedisTestConfig;\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.redis.TaskRedisRepository;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;\r\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\r\nimport org.springframework.context.annotation.Import;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.data.redis.core.ValueOperations;\r\nimport org.springframework.test.context.TestPropertySource;\r\nimport org.testcontainers.junit.jupiter.Container;\r\nimport org.testcontainers.junit.jupiter.Testcontainers;\r\nimport org.testcontainers.utility.DockerImageName;\r\n\r\nimport java.time.Instant;\r\nimport static org.assertj.core.api.Assertions.*;\r\n\r\n// NOTE: REDIS TEST\r\n\r\n/* 2025-11-23-NOTE(S):\r\n- This Integration test verifies that writes to and reads from the Redis layer work.\r\n- Tests JSON serialization via Jackson.\r\n- That TaskRedisRepository.java uses the correct key format.\r\n- Maybe also tests TTL? <-- TO-DO: Maybe come back and do this?\r\n*/\r\n/*@DataRedisTest\r\n@Testcontainers\r\n@SpringJUnitConfig\r\n@TestPropertySource(properties = {\r\n        \"spring.profiles.active=test\" // disables main RedisConfig\r\n})\r\n@Import({ RedisTestConfig.class, TaskRedisRepository.class })*/\r\n// DEBUG: ^ \"@DataRedisTest aggressively filters components. It will NOT load a repository unless you import it before slicing.\"\r\n// DEBUG: so basically I got to do the stuff below now.\r\n/*@SpringJUnitConfig(classes = {\r\n        RedisTestConfig.class,\r\n        TaskRedisRepository.class\r\n})\r\n@DataRedisTest\r\n@Testcontainers\r\n@TestPropertySource(properties = {\r\n        \"spring.profiles.active=test\"\r\n})*/\r\n\r\n@DataRedisTest\r\n@Testcontainers\r\n@TestPropertySource(properties = {\r\n        \"spring.profiles.active=test\"\r\n})\r\n@Import({ RedisTestConfig.class, TaskRedisRepository.class })\r\nclass TaskCacheIntegrationTest {\r\n    @Container\r\n    @ServiceConnection\r\n    static final RedisContainer REDIS =\r\n            new RedisContainer(DockerImageName.parse(\"redis:7.2\"));\r\n    @Autowired\r\n    private TaskRedisRepository cache;\r\n    @Autowired\r\n    private StringRedisTemplate stringRedisTemplate;\r\n\r\n    @Test\r\n    void saveTask_toRedis_canRetrieveFetchTask() {\r\n        // Create Task:\r\n        TaskEntity task = new TaskEntity(\r\n                \"Task-ArbitraryTaskId\",\r\n                \"Send an email\",\r\n                TaskType.EMAIL,\r\n                TaskStatus.QUEUED,\r\n                0,\r\n                3,\r\n                Instant.now()\r\n        );\r\n        // Save it to the Redis layer:\r\n        cache.put(task);\r\n        // Verify the Redis key exists:\r\n        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();\r\n        //String rawJson = ops.get(\"task:Task-ArbitraryTaskId\");\r\n        String rawJson = stringRedisTemplate.opsForValue()\r\n                .get(\"task:Task-ArbitraryTaskId\");\r\n        System.out.println(\"DEBUG RAW = \" + rawJson);\r\n        assertThat(rawJson).isNotNull();\r\n\r\n        // Fetch via repository\r\n        TaskEntity fetched = cache.get(\"Task-ArbitraryTaskId\");\r\n        assertThat(fetched).isNotNull();\r\n        assertThat(fetched.getPayload()).isEqualTo(\"Send an email\");\r\n        assertThat(fetched.getType()).isEqualTo(TaskType.EMAIL);\r\n    }\r\n}\r\n",
      "info": {
        "size": 3708,
        "last_modified": "2025-12-12T15:03:51.0215997",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\integration\\TaskGraphQLIntegrationTest.java",
      "content": "package com.springqprobackend.springqpro.integration;\r\n\r\nimport com.springqprobackend.springqpro.domain.entity.TaskEntity;\r\nimport com.springqprobackend.springqpro.domain.entity.UserEntity;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport com.springqprobackend.springqpro.repository.UserRepository;\r\nimport com.springqprobackend.springqpro.security.JwtUtil;\r\nimport com.springqprobackend.springqpro.testcontainers.IntegrationTestBase;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.boot.test.web.server.LocalServerPort;\r\nimport org.springframework.graphql.test.tester.GraphQlTester;\r\nimport org.springframework.graphql.test.tester.HttpGraphQlTester;\r\nimport org.springframework.test.annotation.DirtiesContext;\r\nimport org.springframework.test.context.ActiveProfiles;\r\nimport org.springframework.test.web.reactive.server.WebTestClient;\r\nimport org.springframework.web.reactive.function.client.ExchangeStrategies;\r\n\r\nimport java.time.Instant;\r\n\r\n/* 2025-11-17-NOTE(S)-TO-SELF:\r\n- GraphQlTester is Spring's testing utility for GraphQL endpoints.\r\nIt's the GraphQL equivalent of [MockMvc for REST], [WebTestClient for reactive HTTP], and [TestRestTemplate for REST integration tests].\r\nGraphQlTester lets you send queries/mutations, inspect fields in the GraphQL response, deserialize response fields into\r\nJava objects (like String, Integer, custom stuff) and assert values using a fluent, chainable API.\r\n*/\r\n/* 2025-11-19-NOTE:\r\nTHE TESTS WORK BUT I KEEP GETTING THIS ERROR BELOW:\r\n\"2025-11-19T12:03:22.382-05:00  WARN 1776 --- [springqpro] [   QS-Worker-99] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: 08006\r\n2025-11-19T12:03:22.383-05:00 ERROR 1776 --- [springqpro] [   QS-Worker-99] o.h.engine.jdbc.spi.SqlExceptionHelper   : An I/O error occurred while sending to the backend.\r\n2025-11-19T12:03:22.387-05:00  INFO 1776 --- [springqpro] [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'\r\n2025-11-19T12:03:22.392-05:00  INFO 1776 --- [springqpro] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...\r\n2025-11-19T12:03:22.401-05:00  INFO 1776 --- [springqpro] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.\"\r\n\r\nI know what the error is. So, basically, my tests succeed BUT my Worker Threads are still active after my\r\nTest completes (and succeeds) and after the Spring test context begins shutting down. So these Threads are\r\ntrying to invoke my atomic SQL operations inside ProcessingService.java inside my Postgres container when\r\nI've already shut it down (Testcontainers has closed it). So, my Worker Threads attempt SQL operations\r\nonly to see the SQL and I/O error. (TL;DR: My async queue processing system is still running during shutdown).\r\n\r\nI NEED TO FINISH THIS PROJECT BEFORE THE END OF NOVEMBER, AND THIS IS SUCH A HASSLE I AM GOING TO LEAVE IT FOR NOW\r\nBECAUSE IT'S JUST A TEST THING AND I REALLY WANT TO FINISH THIS PROJECT BEFORE THE LAST WEEK OF NOVEMBER IF POSSIBLE.\r\nI DON'T HAVE TIME FOR THIS.\r\nTO-DO: FIX THIS PROBLEM PLEASE FOR THE LOVE OF GOD.\r\n*/\r\n//@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\r\n//@Testcontainers\r\n//@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)\r\n@SpringBootTest(\r\n        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,\r\n        properties = {\r\n                \"app.queue.processing.enabled=false\",\r\n                \"spring.task.scheduling.enabled=false\"\r\n        }\r\n)\r\n@ActiveProfiles(\"test\")\r\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\r\nclass TaskGraphQLIntegrationTest extends IntegrationTestBase {\r\n\r\n    private GraphQlTester graphQlTester;\r\n\r\n    @LocalServerPort\r\n    private int port;\r\n\r\n    @Autowired\r\n    private TaskRepository taskRepository;\r\n\r\n    @Autowired\r\n    private UserRepository userRepository;\r\n\r\n    @Autowired\r\n    private JwtUtil jwtUtil;\r\n\r\n    private static final String TEST_EMAIL = \"graphql-test@example.com\";\r\n\r\n    @BeforeEach\r\n    void init() {\r\n        taskRepository.deleteAll();\r\n        userRepository.deleteAll();\r\n        // Create a user so SecurityContext + ownership is valid\r\n        userRepository.save(new UserEntity(\r\n                TEST_EMAIL,\r\n                \"{noop}password\" // password not used here; we just need a valid user record\r\n        ));\r\n        // Generate a valid JWT for that user\r\n        String token = jwtUtil.generateAccessToken(TEST_EMAIL);\r\n\r\n        WebTestClient client = WebTestClient.bindToServer()\r\n                .baseUrl(\"http://localhost:\" + port + \"/graphql\")\r\n                .exchangeStrategies(\r\n                        ExchangeStrategies.builder()\r\n                                .codecs(c -> c.defaultCodecs().maxInMemorySize(5_000_000))\r\n                                .build()\r\n                )\r\n                .defaultHeader(\"Authorization\", \"Bearer \" + token)\r\n                .build();\r\n        this.graphQlTester = HttpGraphQlTester.create(client);\r\n    }\r\n\r\n    // Test #1 - Create Task, Query the Task, then verify its Status, Type, and Payload:\r\n    @Test\r\n    void taskCreation_succeeds_isRetrieved() {\r\n        String mutation = \"\"\"\r\n                mutation {\r\n                    createTask(input:{\r\n                        payload:\"send-an-email\"\r\n                        type:EMAIL\r\n                    }) {\r\n                        id\r\n                        payload\r\n                        type\r\n                        status\r\n                        attempts\r\n                        maxRetries\r\n                    }\r\n                }\r\n                \"\"\";\r\n        /*2025 - 11 - 17 - NOTE(S) - TO - SELF:+DEBUG:\r\n        -graphQlTester.document(mutation) prepares a GraphQL mutation with String mutation, which is just a String\r\n        containing\r\n        a proper GraphQL mutation obv.So graphQlTester runs it by running my actual Spring Boot app(which runs my real\r\n                GraphQL controller, my real service layer, and uses the real database(Testcontainers in this\r\n        case)).\r\n        - .execute() clearly runs it and you can inspect the fields.*/\r\n        var created = graphQlTester.document(mutation)\r\n            .execute()\r\n            .path(\"createTask.payload\").entity(String.class).isEqualTo(\"send-an-email\")\r\n            .path(\"createTask.type\").entity(String.class).isEqualTo(\"EMAIL\")\r\n            .path(\"createTask.status\").entity(String.class).isEqualTo(\"QUEUED\");\r\n        // Extract the id from the same GraphQL mutation:\r\n        String id = graphQlTester.document(mutation)\r\n                .execute()\r\n                .path(\"createTask.id\").entity(String.class).get();\r\n        // Search for that Task w/ a GraphQL query:\r\n        String query = \"\"\"\r\n                query {\r\n                    task(id: \"%s\") {\r\n                        id\r\n                        payload\r\n                        type\r\n                        status\r\n                    }\r\n                }\r\n                \"\"\".formatted(id);\r\n        graphQlTester.document(query)\r\n                .execute()\r\n                .path(\"task.payload\").entity(String.class).isEqualTo(\"send-an-email\")\r\n                .path(\"task.type\").entity(String.class).isEqualTo(\"EMAIL\");\r\n    }\r\n\r\n    // Test #2 - Update Task (Partially), Verify Change in DB, Query Returns Updated:\r\n    @Test\r\n    void updateTask_verifyDBChange_retrieveByQuery() {\r\n        TaskEntity entity = new TaskEntity(\r\n                \"Task-ArbitraryTaskId\",\r\n                \"Send an email\",\r\n                TaskType.EMAIL,\r\n                TaskStatus.QUEUED,\r\n                0,\r\n                3,\r\n                Instant.now(),\r\n                TEST_EMAIL\r\n        );\r\n        taskRepository.save(entity);\r\n        // Manually change the status of entity to COMPLETED and increment attempts:\r\n        // NOTE: When you want to specify integer in mutation, put %d -- \"%d\" will return you a integer wrapped in a String (aka just a String)\r\n        String mutation = \"\"\"\r\n                mutation {\r\n                    updateTask(input:{\r\n                        id:\"%s\",\r\n                        status:COMPLETED,\r\n                        attempts:%d\r\n                    }) {\r\n                        id\r\n                        status\r\n                        attempts\r\n                    }\r\n                }\r\n                \"\"\".formatted(entity.getId(), entity.getAttempts()+1);\r\n        graphQlTester.document(mutation).execute()\r\n                .path(\"updateTask.status\").entity(String.class).isEqualTo(\"COMPLETED\")\r\n                .path(\"updateTask.attempts\").entity(Integer.class).isEqualTo(1);\r\n        // Verify that the change happened in the DataBase w/ taskRepository:\r\n        TaskEntity getEntity = taskRepository.findById(entity.getId()).orElseThrow();\r\n        assert getEntity.getStatus() == TaskStatus.COMPLETED;\r\n        assert getEntity.getAttempts() == entity.getAttempts() + 1;\r\n    }\r\n\r\n    // Test #3 - Delete Task, Verify Change in DB, Query Returns NULL (or whatever):\r\n    @Test\r\n    void deleteTask_verifyDBChange_queryRetrieveNull() {\r\n        TaskEntity entity = new TaskEntity(\r\n                \"Task-ArbitraryTaskId\",\r\n                \"Send an email\",\r\n                TaskType.EMAIL,\r\n                TaskStatus.QUEUED,\r\n                0,\r\n                3,\r\n                Instant.now(),\r\n                TEST_EMAIL\r\n        );\r\n        taskRepository.save(entity);\r\n        String mutation = \"\"\"\r\n                mutation {\r\n                    deleteTask(id:\"%s\")\r\n                }\r\n                \"\"\".formatted(entity.getId());\r\n        graphQlTester.document(mutation)\r\n                .execute()\r\n                .path(\"deleteTask\").entity(Boolean.class).isEqualTo(true);\r\n        assert taskRepository.findById(entity.getId()).isEmpty();\r\n    }\r\n\r\n    // Test #4 - Being able to filter Tasks w/ Status:\r\n    @Test\r\n    void filterTasks_byStatusQuery_returnsCorrectList() {\r\n        // Task #1:\r\n        taskRepository.save(\r\n                new TaskEntity(\"Task-ArbitraryTaskId-1\",\"Send an email\", TaskType.EMAIL, TaskStatus.QUEUED, 0, 3, Instant.now(), TEST_EMAIL)\r\n        );\r\n        // Task #2:\r\n        taskRepository.save(\r\n                new TaskEntity(\"Task-ArbitraryTaskId-2\", \"Send an email 2\", TaskType.EMAIL, TaskStatus.COMPLETED, 1, 3, Instant.now(), TEST_EMAIL)\r\n        );\r\n        // Task #3:\r\n        taskRepository.save(\r\n                new TaskEntity(\"Task-ArbitaryTaskId-3\", \"Send an SMS or whatever\", TaskType.SMS, TaskStatus.QUEUED, 0, 3, Instant.now(), TEST_EMAIL)\r\n        );\r\n        String query = \"\"\"\r\n                query {\r\n                    tasks(status: QUEUED) {\r\n                        id\r\n                        payload\r\n                        status\r\n                    }\r\n                }\r\n                \"\"\";\r\n        graphQlTester.document(query)\r\n                .execute()\r\n                .path(\"tasks\").entityList(TaskEntity.class).hasSize(2);\r\n    }\r\n\r\n    // Test #5 - Being able to filter Tasks w/ Type:\r\n    @Test\r\n    void filterTasks_byTypeQuery_returnsCorrectList() {\r\n        // Task #1:\r\n        taskRepository.save(\r\n                new TaskEntity(\"Task-ArbitraryTaskId-1\",\"Do something NEWSLETTER related, I don't know.\", TaskType.NEWSLETTER, TaskStatus.QUEUED, 0, 3, Instant.now(), TEST_EMAIL)\r\n        );\r\n        // Task #2:\r\n        taskRepository.save(\r\n                new TaskEntity(\"Task-ArbitraryTaskId-2\", \"Do something NEWSLETTER related, I don't know 2.\", TaskType.NEWSLETTER, TaskStatus.COMPLETED, 1, 3, Instant.now(), TEST_EMAIL)\r\n        );\r\n        // Task #3:\r\n        taskRepository.save(\r\n                new TaskEntity(\"Task-ArbitraryTaskId-3\", \"Send an SMS or whatever\", TaskType.SMS, TaskStatus.QUEUED, 0, 3, Instant.now(), TEST_EMAIL)\r\n        );\r\n        // Task #4:\r\n        taskRepository.save(\r\n                new TaskEntity(\"Task-ArbitraryTaskId-4\", \"Do something NEWSLETTER related, I don't know 3.\", TaskType.NEWSLETTER, TaskStatus.QUEUED, 0, 3, Instant.now(), TEST_EMAIL)\r\n        );\r\n        String query = \"\"\"\r\n                query {\r\n                    tasksType(type: NEWSLETTER) {\r\n                        id\r\n                        payload\r\n                        status\r\n                    }\r\n                }\r\n                \"\"\";\r\n        graphQlTester.document(query)\r\n                .execute()\r\n                .path(\"tasksType\").entityList(TaskEntity.class).hasSize(3);\r\n    }\r\n}\r\n",
      "info": {
        "size": 12908,
        "last_modified": "2025-12-12T15:03:51.0306777",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\models\\TaskHandlerRegistryTests.java",
      "content": "package com.springqprobackend.springqpro.models;\r\n\r\n/* NOTE: File TaskHandlerRegistry.java has no external dependencies beyond the map where classes that\r\nimplement the interface are injected. That means that no mocks are needed here (other than maybe\r\nmocking the handlers themselves). */\r\n\r\nimport com.springqprobackend.springqpro.handlers.TaskHandler;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\nimport static org.junit.jupiter.api.Assertions.assertEquals;\r\nimport static org.mockito.Mockito.mock;\r\n\r\n/* All that needs to be tested is:\r\n- Make sure that the correct handler is returned for a specific key (e.g., EmailHandler if getHandler(\"EMAIL\")).\r\n- Returns DefaultHandler if type is missing.\r\n- getAllHandlers() exposes all of the handlers.\r\n*/\r\npublic class TaskHandlerRegistryTests {\r\n    private TaskHandler defaultHandler;\r\n    private Map<String, TaskHandler> map;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        defaultHandler = mock(TaskHandler.class);\r\n        //map = Map.of(\"DEFAULT\", defaultHandler);\r\n        map = new HashMap<>();\r\n        map.put(\"DEFAULT\", defaultHandler);\r\n    }\r\n\r\n    @Test\r\n    void getHandler_returns_correctHandler() {\r\n        TaskHandler emailHandler = mock(TaskHandler.class);\r\n        /*TaskHandler defaultHandler = mock(TaskHandler.class);\r\n        Map<String, TaskHandler> map = Map.of(\r\n                \"EMAIL\", emailHandler,\r\n                \"DEFAULT\", defaultHandler\r\n        );*/\r\n        map.put(\"EMAIL\", emailHandler);\r\n        TaskHandlerRegistry registry = new TaskHandlerRegistry(map);\r\n        assertEquals(emailHandler, registry.getHandler(\"EMAIL\"));\r\n    }\r\n\r\n    @Test\r\n    void unknownHandler_defaultsTo_defaultHandler() {\r\n        /*TaskHandler defaultHandler = mock(TaskHandler.class);\r\n        Map<String, TaskHandler> map = Map.of(\r\n                \"DEFAULT\", defaultHandler\r\n        );*/\r\n        TaskHandlerRegistry registry = new TaskHandlerRegistry(map);\r\n        assertEquals(defaultHandler, registry.getHandler(\"IDONTKNOW\"));\r\n    }\r\n\r\n    @Test\r\n    void getAllHandlers_returns_injectedMap() {\r\n        TaskHandlerRegistry registry = new TaskHandlerRegistry(map);\r\n        assertEquals(map, registry.getAllHandlers());\r\n    }\r\n}\r\n",
      "info": {
        "size": 2295,
        "last_modified": "2025-12-12T15:03:51.0404365",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\runtime\\WorkerTests.java",
      "content": "package com.springqprobackend.springqpro.runtime;\r\n\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.handlers.TaskHandler;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.models.TaskHandlerRegistry;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.mockito.Mock;\r\nimport org.mockito.junit.jupiter.MockitoExtension;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\nimport static org.mockito.Mockito.*;\r\n\r\n/* NOTE: This function got much simpler after adding the TaskHandlerRegistry and global exception\r\nhandler. Writing tests should be relatively simple.\r\nAgain:\r\n- More on different assert methods: https://www.baeldung.com/junit-assertions\r\n*/\r\n\r\n@ExtendWith(MockitoExtension.class)\r\npublic class WorkerTests {\r\n    @Mock\r\n    private TaskHandlerRegistry handlerRegistry;\r\n    @Mock\r\n    private TaskHandler mockHandler;\r\n\r\n    private Task t;\r\n    private Worker worker;\r\n\r\n    @BeforeEach\r\n    void setUp() {\r\n        t = new Task();\r\n        t.setId(\"Task-ArbitraryTaskId\");\r\n        t.setType(TaskType.EMAIL);\r\n        t.setMaxRetries(3); // DEBUG: Shouldn't be necessary but doesn't hurt to have (?)\r\n        when(handlerRegistry.getHandler(\"EMAIL\")).thenReturn(mockHandler);\r\n        worker = new Worker(t, handlerRegistry);\r\n    }\r\n\r\n    @Test\r\n    void testWorker_runsAndInvokes_correctHandler() throws Exception {\r\n        worker.run();\r\n        verify(mockHandler, times(1)).handle(eq(t));\r\n        // \"eq\" supposed to guarantee that the argument passed when the handle method occurred was equal to \"t\".\r\n    }\r\n\r\n    @Test\r\n    void testWorker_whenInterrupted_handlesException() throws Exception {\r\n        doThrow(new RuntimeException(\"NO IT DIDN'T IT HANDLED THE ERROR JUST RIGHT!!!\")).when(mockHandler).handle(any(Task.class));\r\n        worker.run();\r\n        assertEquals(TaskStatus.FAILED, t.getStatus());\r\n    }\r\n\r\n}\r\n",
      "info": {
        "size": 2089,
        "last_modified": "2025-12-12T15:03:51.0646538",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\service\\QueueServiceTests.java",
      "content": "package com.springqprobackend.springqpro.service;\r\n\r\nimport com.springqprobackend.springqpro.config.QueueProperties;\r\nimport com.springqprobackend.springqpro.models.TaskHandlerRegistry;\r\nimport com.springqprobackend.springqpro.models.Task;\r\nimport com.springqprobackend.springqpro.enums.TaskType;\r\nimport com.springqprobackend.springqpro.enums.TaskStatus;\r\nimport com.springqprobackend.springqpro.repository.TaskRepository;\r\nimport io.micrometer.core.instrument.Counter;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Disabled;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.extension.ExtendWith;\r\nimport org.mockito.Mock;\r\nimport org.mockito.junit.jupiter.MockitoExtension;\r\n\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.concurrent.AbstractExecutorService;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\nimport static org.junit.jupiter.api.Assertions.*;\r\nimport static org.mockito.Mockito.*;\r\n\r\n/* NOTE(S)-TO-SELF:\r\n- More on different assert methods: https://www.baeldung.com/junit-assertions\r\n*/\r\n// remember to scan back after and put any code that's mimicked across all tests in the @BeforeEach method!\r\n\r\n/* Some other tests I can maybe write that aren't super high priority:\r\n- Double enqueue prevention (code should reject duplicate IDs -- actually don't know if that's in the code).\r\n- Max retry logic (task doesnt re-enqueue beyond maxAttempts).\r\n- Shutdown behavior (test service gracefully stops workers when needed).\r\n- HandlerRegistry fallback  test that when no handler exists, the default handler runs.\r\n*/\r\n\r\n@ExtendWith(MockitoExtension.class)\r\npublic class QueueServiceTests {\r\n\r\n    /* NOTE: Called DirectExecutorServiec because it runs commands immediately within the same thread\r\n    (so I don't need to hassle with sleeps, race conditions, and all the concurrency-related headaches in testing). */\r\n    private static class DirectExecutorService extends AbstractExecutorService {\r\n        @Override public void shutdown() {}\r\n        @Override public List<Runnable> shutdownNow() { return Collections.emptyList(); }\r\n        @Override public boolean isShutdown() { return false; }\r\n        @Override public boolean isTerminated() { return false; }\r\n        @Override public boolean awaitTermination(long timeout, TimeUnit unity) { return true; }\r\n        @Override\r\n        public void execute(Runnable command) {\r\n            /* Runs immediately in the calling thread. This is all that we're interested in using.\r\n            The whole purpose of this nested private class definition is so we can run this function.\r\n            (I'm using an ExecutorService in QueueService which is an extension of the Executor service.\r\n            Ideally, I would have just done Executor ... = Runnable::run, but you can't do that\r\n            w/ ExecutorService because it extends Executor and implements additional methods, so we have\r\n            to implement them above (just the stubs) so we can run that. */\r\n            /* NOTE: It's apparently best practice to inject an Executor for testing w/o sleeps or leniency stubs.\r\n            (It's ideal to do that when testing systems where concurrency is involved, like this one). */\r\n            command.run();  // runs immediately in the calling thread. This is all we're interested in\r\n        }\r\n    }\r\n\r\n    @Mock\r\n    private TaskHandlerRegistry handlerRegistry;\r\n    @Mock\r\n    private ExecutorService mockExecutor;\r\n    @Mock\r\n    private QueueProperties props;\r\n    @Mock\r\n    private TaskRepository taskRepo;\r\n    @Mock\r\n    private ProcessingService proService;\r\n    @Mock\r\n    private Counter queueEnqueueCounter;\r\n    @Mock\r\n    private Counter queueEnqueueByIdCounter;\r\n    private QueueService queue;\r\n    private Task t;\r\n\r\n    /* NOTE: I can't do @InjectMocks over private QueueService queue; because the constructor arg list for my QueueService class\r\n    looks like this: (@Value(\"${worker.count}\") int workerCount, TaskHandlerRegistry handlerRegistry) and Mockito cannot autowire\r\n    the constructor since it doesn't manage @Value(\"{worker.count}\").\r\n    -- There's probably a way to work around this, but for fast isolated unit tests, it's better to either do something like:\r\n    \"@BeforeEach\r\n     void setUp() {\r\n         MockitoAnnotations.openMocks(this); // Initializes all mocks (and related annotations) before each test.\r\n         queue = new QueueService(2, handlerRegistry);\r\n     }\"\r\n    The MockitoAnnotations line can be automated and omitted w/ @ExtendWith(MockitoExtension.class) */\r\n    @BeforeEach\r\n    void setUp() {\r\n        ExecutorService immediateExecutor = new DirectExecutorService();\r\n        //when(props.getMainExecWorkerCount()).thenReturn(5);\r\n        //when(props.getSchedExecWorkerCount()).thenReturn(1);\r\n        queue = new QueueService(immediateExecutor, handlerRegistry, taskRepo, proService, props, queueEnqueueCounter, queueEnqueueByIdCounter);   // Manually constructing the queue (which is why there's no annotation above it earlier).\r\n        // Init Task w/ no-args constructor:\r\n        t = new Task();\r\n        // id and type fields are the ubiquitous fields for testing (e.g., for identification):\r\n        t.setId(\"Task-ArbitraryTestId\");\r\n        t.setType(TaskType.EMAIL);\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void enqueue_shouldAddTask_toJobsMap() {\r\n        // DEBUG:+NOTE: No type field causes error I'm pretty sure. Not sure about id though (maybe it should -- come back and look into this later).\r\n        queue.enqueue(t);\r\n        /* EDIT: So it checks for FAILED before for a reason. We don't really care about what the Worker/Executor actually does, I just want to\r\n        make sure that this Task gets enqueued into the pool and added to the jobs map (and so on). It will FAIL because I'm now relying on the\r\n        direct executor that I define in the nested class. So even if I have a when...thenReturn(); call somewhere, it won't work. But that's okay\r\n        because that's not really the concern of this Test. (I could just not use the direct executor if this were something I were actually concerned about). */\r\n        assertEquals(TaskStatus.FAILED, t.getStatus());\r\n        assertEquals(1, queue.getJobMapCount());    // Each test runs in isolation, so 1 job w/ only one task queued.\r\n        assertNotNull(queue.getJobById(\"Task-ArbitraryTestId\"));\r\n        /* NOTE: Tasks of Type EMAIL take ~2 seconds to finish execution (after which, their Type becomes COMPLETED).\r\n        I could potentially make this thread sleep for 2-3 seconds and then check after to see if the type becomes COMPLETED.\r\n        But I think it's supposed to be bad practice doing that in Unit Tests since they're meant to be very quick...\r\n        */\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void clear_shouldEmpty_theJobsMap() {\r\n        queue.enqueue(t);   // enqueue this job just so that the clear method can be invoked.\r\n\r\n        // DEBUG: Not sure if this would work honestly. Get some clarity on if the execution of this test would be sequential (it should be right? Why am I questioning this?)\r\n        queue.clear();\r\n        assertEquals(0, queue.getJobMapCount());\r\n        assertNull(queue.getJobById(\"Task-ArbitraryTestId\"), ()->\"The value returned by getJobById() should be null post-clear()\");\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void jobsMap_canMap_manyJobs() {\r\n        // t is declared in @BeforeEach method\r\n        Task t2 = new Task();\r\n        t2.setId(\"Task-ArbitraryTestId2\");\r\n        t.setType(TaskType.EMAIL);\r\n        queue.enqueue(t);\r\n        queue.enqueue(t2);\r\n        assertEquals(2, queue.getJobMapCount());\r\n        assertNotNull(queue.getJobById(\"Task-ArbitraryTestId\"));\r\n        assertNotNull(queue.getJobById(\"Task-ArbitraryTestId2\"));\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void delete_shouldRemoveJob_fromJobsMap() {\r\n        queue.enqueue(t);\r\n\r\n        queue.deleteJob(\"Task-ArbitraryTestId\");\r\n        assertEquals(0, queue.getJobMapCount());\r\n        assertNull(queue.getJobById(\"Task-ArbitraryTestId\"), ()-> \"The value returned by getJobById(\\\"id\\\") should be null after deleting the job identified by \\\"id\\\"\");\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void retry_shouldEnqueue_failedTask() throws InterruptedException {\r\n        t.setStatus(TaskStatus.FAILED); // Append to t.\r\n        /* NOTE: Originally had the when...thenReturn(...); function definition below in the @Test methods above too,\r\n        but they would invoke unused stubbing errors when you'd attempt to run the tests. That's because the enqueue function\r\n        is asynchronous (or rather async up until the task is enqueued into the executorService, but the test finishes almost\r\n        immediately after that (the when... func never runs) -- and in the context of those tests, we don't care about what\r\n        the instantiated Worker class does). */\r\n        // NOTE: ^ Regardless, I still do get warnings in the console that seem to occur after each test completes...\r\n        when(handlerRegistry.getHandler(\"EMAIL\")).thenReturn(task -> {\r\n            t.setStatus(TaskStatus.INPROGRESS); // EDIT: Was .COMPLETED, adjusted to .INPROGRESS.\r\n        }); // <-- NOTE: (Cont) we have basically two delays below (which ensure that this func *will* be met).\r\n\r\n        /* NOTE: retry method in QueueService.java is supposed to *not run* if the task you send in is NOT a FAILED status type.\r\n        I think that might have been removed from my code when I refactored away from the switch-case method of handling different tasks.\r\n        (I'm not 100% sure, come back to this and do some more digging - can probably be another unit test in this file). */\r\n        queue.retry(t, 10);\r\n        TimeUnit.MILLISECONDS.sleep(20);\r\n        /* In the context of this text below, I think we can just it check if the TaskStatus is COMPLETED (we're defining the\r\n        handler behavior in the when...thenReturn(); method above anyways; I could have made it be QUEUED instead). */\r\n\r\n        /* After originally having .COMPLETED in the when...thenReturn(); function above, I've picked up that the minor delays\r\n        I enforce in this test delay it enough that the queued Worker reaches the stage where its Task Status is set to INPROGRESS.\r\n        So, I may as well just also have the when...thenReturn(); function set the same (since we just want to make sure that it\r\n        gets re-enqueued regardless of what the status is when we check). */\r\n        assertEquals(TaskStatus.INPROGRESS, queue.getJobById(\"Task-ArbitraryTestId\").getStatus());\r\n        assertEquals(1, queue.getJobMapCount());\r\n    }\r\n\r\n    @Disabled\r\n    @Test\r\n    void retry_shouldReject_nonFailedTask() {\r\n        t.setStatus(TaskStatus.COMPLETED);  // .retry(...) should reject tasks/jobs of status non-FAILED.\r\n        queue.retry(t, 10);\r\n        // I think we can omit the TimeUnit...sleep and when...thenReturn because we're expecting auto-rejection.\r\n\r\n        assertNull(queue.getJobById(\"Task-ArbitraryTestId\"));\r\n        assertEquals(0, queue.getJobMapCount());\r\n    }\r\n\r\n    /* NOTE: I also want to test for my ExecutorService field in QueueService is it properly shutting down.\r\n    (Making sure that @PreDestroy, shutdown() methods etc correctly terminate the executor).\r\n    But that's trickier since ExecutorService *is* an internal field. So I'll have to add that as a @Mock field here.\r\n    Here's what we'd be testing directly:\r\n    1. When shutdown() is called, it invokes executor.shutdown();\r\n    2. If the executor doesn't terminate in time, it calls executor.shutdownNow();\r\n    3. It handles InterruptedException correctly (interrupts the current thread and calls shutdownNow()). */\r\n    // 1.\r\n    @Test\r\n    void shutdown_shouldTerminateExecutorService() throws InterruptedException {\r\n        when(mockExecutor.awaitTermination(anyLong(), any())).thenReturn(true);\r\n        QueueService queueService = new QueueService(mockExecutor, handlerRegistry, taskRepo, proService, props, queueEnqueueCounter, queueEnqueueByIdCounter);\r\n        queueService.shutdown();    // voila.\r\n\r\n        verify(mockExecutor).shutdown();\r\n        verify(mockExecutor).awaitTermination(5, TimeUnit.SECONDS);\r\n        verify(mockExecutor, never()).shutdownNow();\r\n    }\r\n    // 2.\r\n    @Test\r\n    void shutdown_shouldTerminate_ifTimeoutOccurs() throws InterruptedException {\r\n        when(mockExecutor.awaitTermination(anyLong(), any())).thenReturn(false); // simulate timeout.\r\n        QueueService service = new QueueService(mockExecutor, handlerRegistry, taskRepo, proService, props, queueEnqueueCounter, queueEnqueueByIdCounter);\r\n        service.shutdown();\r\n\r\n        verify(mockExecutor).shutdown();\r\n        verify(mockExecutor).awaitTermination(5, TimeUnit.SECONDS);\r\n        verify(mockExecutor).shutdownNow();  // force shutdown should trigger.\r\n    }\r\n    // 3.\r\n    @Test\r\n    void shutdown_shouldForceTerminate_ifInterrupted() throws InterruptedException {\r\n        when(mockExecutor.awaitTermination(anyLong(), any())).thenThrow(new InterruptedException(\"simulated interruption\"));\r\n\r\n        QueueService service = new QueueService(mockExecutor, handlerRegistry, taskRepo, proService, props, queueEnqueueCounter, queueEnqueueByIdCounter);\r\n        service.shutdown();\r\n\r\n        verify(mockExecutor).shutdown();\r\n        verify(mockExecutor).shutdownNow();\r\n        // Verify that the thread was interrupted again\r\n        assertTrue(Thread.interrupted(), \"Current thread should be re-interrupted after catching InterruptedException\");\r\n    }\r\n\r\n}",
      "info": {
        "size": 13612,
        "last_modified": "2025-12-12T15:03:51.0724229",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\SpringQueueProApplicationTests.java",
      "content": "package com.springqprobackend.springqpro;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.autoconfigure.ImportAutoConfiguration;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass SpringQueueProApplicationTests {\n\n\t@Test\n\tvoid contextLoads() {\n        System.out.println(\"I'm testing this file right now. What's all this then?\");\n\t}\n\n}\n",
      "info": {
        "size": 389,
        "last_modified": "2025-12-12T15:03:51.0957773",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\testcontainers\\BasePostgresContainer.java",
      "content": "package com.springqprobackend.springqpro.testcontainers;\r\n\r\nimport com.redis.testcontainers.RedisContainer;\r\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\r\nimport org.testcontainers.containers.PostgreSQLContainer;\r\nimport org.testcontainers.junit.jupiter.Container;\r\nimport org.testcontainers.utility.DockerImageName;\r\n\r\n/* 2025-11-23-NOTE(S):+DEBUG:\r\nSO, WHAT I WANT TO DO IS REFACTOR MY TEST SETUP SO THAT THE INTEGRATION TESTS ARE LESS \"HEAVY\".\r\nI HAVE A PROBLEM RIGHT NOW WHERE MY 4 CORE NON-REDIS RELATED INTEGRATION TESTS ARE LOADING THE WHOLE\r\nSPRING CONTEXT TO RUN EACH TEST WHICH IS SLOW AND INEFFICIENT. BUT I'VE REFACTORED PROCESSINGSERVICE.JAVA\r\nAND TASKSERVICE.JAVA TO INTEGRATE REDIS AS PART OF REFACTORING. SO THE BEST FIX I CAN HAVE FOR NOW\r\nIS TO JUST SPIN UP A REDIS CONTAINER INSIDE OF THIS FILE -- BUT IT'S ONLY TEMPORARY, AND I WILL COME BACK\r\nTO FIX THIS AND MAKE IT MORE PROFESSIONALLY TIDY AFTER I GET MY CORE PROJECT DONE AND RESUME READY. (ON TIME CRUNCH).\r\n*/\r\n// CENTRAL PostgreSQL Testcontainer USED FOR ALL MY INTEGRATION TESTS:\r\npublic abstract class BasePostgresContainer {\r\n    @ServiceConnection\r\n    protected static final PostgreSQLContainer<?> POSTGRES =\r\n            new PostgreSQLContainer<>(\"postgres:18\")\r\n                    .withDatabaseName(\"springqpro\")\r\n                    .withUsername(\"springqpro\")\r\n                    .withPassword(\"springqpro\")\r\n                    .withReuse(true);\r\n    // 2025-11-23-DEBUG: TEMP BELOW.\r\n    @Container\r\n    @ServiceConnection\r\n    static final RedisContainer REDIS =\r\n            new RedisContainer(DockerImageName.parse(\"redis:7.2\"));\r\n    // 2025-11-23-DEBUG: TEMP ABOVE.\r\n\r\n    static {\r\n        POSTGRES.start();   // This is meant to boot once for the entire Integration Test Suite.\r\n        REDIS.start();  // 2025-11-23-DEBUG: TEMP.\r\n    }\r\n}\r\n",
      "info": {
        "size": 1878,
        "last_modified": "2025-12-12T15:03:51.1062678",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\testcontainers\\BaseRedisContainer.java",
      "content": "package com.springqprobackend.springqpro.testcontainers;\r\n\r\nimport org.springframework.boot.testcontainers.service.connection.ServiceConnection;\r\nimport org.testcontainers.containers.GenericContainer;\r\n\r\npublic abstract class BaseRedisContainer {\r\n    @ServiceConnection\r\n    protected static final GenericContainer<?> REDIS\r\n            = new GenericContainer<>(\"redis:7-alpine\")\r\n            .withExposedPorts(6379)\r\n            .withReuse(true);\r\n    static {\r\n        REDIS.start();\r\n    }\r\n}\r\n",
      "info": {
        "size": 498,
        "last_modified": "2025-12-12T15:03:51.1136166",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\testcontainers\\IntegrationTestBase.java",
      "content": "package com.springqprobackend.springqpro.testcontainers;\r\n\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.testcontainers.junit.jupiter.Testcontainers;\r\n\r\n/* BASE CLASS FOR ALL MY INTEGRATION TESTS THAT PROVIDES:\r\n- Spring Boot test lifecycle.\r\n- RANDOM_PORT server for GraphQL tests.\r\n- Testcontainers lifecycle.\r\n- PostgreSQL datasource auto-wiring from BasePostgresContainer.\r\n*/\r\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, properties = \"spring.main.allow-bean-definition-overriding=true\")\r\n@Testcontainers\r\npublic abstract class IntegrationTestBase extends BasePostgresContainer {\r\n}",
      "info": {
        "size": 646,
        "last_modified": "2025-12-12T15:03:51.126198",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\java\\com\\springqprobackend\\springqpro\\testcontainers\\RedisIntegrationTestBase.java",
      "content": "package com.springqprobackend.springqpro.testcontainers;\r\n\r\nimport com.springqprobackend.springqpro.config.RedisTestConfig;\r\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\r\nimport org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.context.annotation.Import;\r\nimport org.springframework.test.context.DynamicPropertyRegistry;\r\nimport org.springframework.test.context.DynamicPropertySource;\r\nimport org.testcontainers.junit.jupiter.Testcontainers;\r\n\r\n@DataRedisTest\r\n@Testcontainers\r\n@Import(RedisTestConfig.class)\r\n@EnableAutoConfiguration(exclude = {\r\n        org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration.class,\r\n        org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration.class,\r\n        org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration.class\r\n})\r\npublic abstract class RedisIntegrationTestBase extends BaseRedisContainer {\r\n    @DynamicPropertySource\r\n    static void overrideRedisProps(DynamicPropertyRegistry registry) {\r\n        registry.add(\"spring.redis.host\", REDIS::getHost);\r\n        registry.add(\"spring.redis.port\", () -> REDIS.getMappedPort(6379));\r\n    }\r\n}",
      "info": {
        "size": 1287,
        "last_modified": "2025-12-12T15:03:51.1359884",
        "mime_type": "text/x-java-source",
        "extension": ".java"
      }
    },
    {
      "path": "test\\resources\\application-test.properties",
      "content": "app.queue.processing.enabled=false\r\nspring.task.scheduling.enabled=false\r\n",
      "info": {
        "size": 74,
        "last_modified": "2025-12-12T15:03:51.183369",
        "mime_type": "text/x-java-properties",
        "extension": ".properties"
      }
    },
    {
      "path": "test\\resources\\application-test.yml",
      "content": "spring:\r\n  main:\r\n    allow-bean-definition-overriding: true\r\n",
      "info": {
        "size": 62,
        "last_modified": "2025-12-12T15:03:51.1933987",
        "mime_type": "text/x-yaml",
        "extension": ".yml"
      }
    }
  ]
}